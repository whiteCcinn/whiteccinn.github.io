<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>【网络协议】TCP - tcpdump用法 | 白菜君の技术库</title>

  
  <meta name="author" content="白菜(whiteCcinn)">
  

  
  <meta name="description" content="知道做不到，等于不知道">
  

  
  <meta name="keywords" content="白菜,文辉,技术博客,whiteCcinn">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="【网络协议】TCP - tcpdump用法"/>

  <meta property="og:site_name" content="白菜君の技术库"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="白菜君の技术库" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">白菜君の技术库</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/">文章</a></li>
      
        <li><a href="/tags/">标签</a></li>
      
        <li><a href="/categories/">分类</a></li>
      
        <li><a href="/about/">关于我</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>【网络协议】TCP - tcpdump用法</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/08/07/网络协议/TCP-tcpdump/" rel="bookmark">
        <time class="entry-date published" datetime="2019-08-07T07:57:13.000Z">
          2019-08-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于我们在服务器上编程或者调试的时候，都不可能是各种抓包客户端，所以我们需要学会运用 tcpdump 来对网络的数据进行抓包。<br>用简单的话来定义 tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump 可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供 and、or、not 等逻辑语句来帮助你去掉无用的信息。</p>
<a id="more"></a>

<h2 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">-A  以ASCII码方式显示每一个数据包(不会显示数据包中链路层头部信息). 在抓取包含网页数据的数据包时, 可方便查看数据(nt: 即Handy for capturing web pages).</span><br><span class="line"></span><br><span class="line">-c  count</span><br><span class="line">    tcpdump将在接受到count个数据包后退出.</span><br><span class="line"></span><br><span class="line">-C  file-size (nt: 此选项用于配合-w file 选项使用)</span><br><span class="line">    该选项使得tcpdump 在把原始数据包直接保存到文件中之前, 检查此文件大小是否超过file-size. 如果超过了, 将关闭此文件,另创一个文件继续用于原始数据包的记录. 新创建的文件名与-w 选项指定的文件名一致, 但文件名后多了一个数字.该数字会从1开始随着新创建文件的增多而增加. file-size的单位是百万字节(nt: 这里指1,000,000个字节,并非1,048,576个字节, 后者是以1024字节为1k, 1024k字节为1M计算所得, 即1M&#x3D;1024 ＊ 1024 ＝ 1,048,576)</span><br><span class="line"></span><br><span class="line">-d  以容易阅读的形式,在标准输出上打印出编排过的包匹配码, 随后tcpdump停止.(nt | rt: human readable, 容易阅读的,通常是指以ascii码来打印一些信息. compiled, 编排过的. packet-matching code, 包匹配码,含义未知, 需补充)</span><br><span class="line"></span><br><span class="line">-dd 以C语言的形式打印出包匹配码.</span><br><span class="line"></span><br><span class="line">-ddd 以十进制数的形式打印出包匹配码(会在包匹配码之前有一个附加的&#39;count&#39;前缀).</span><br><span class="line"></span><br><span class="line">-D  打印系统中所有tcpdump可以在其上进行抓包的网络接口. 每一个接口会打印出数字编号, 相应的接口名字, 以及可能的一个网络接口描述. 其中网络接口名字和数字编号可以用在tcpdump 的-i flag 选项(nt: 把名字或数字代替flag), 来指定要在其上抓包的网络接口.</span><br><span class="line"></span><br><span class="line">    此选项在不支持接口列表命令的系统上很有用(nt: 比如, Windows 系统, 或缺乏 ifconfig -a 的UNIX系统); 接口的数字编号在windows 2000 或其后的系统中很有用, 因为这些系统上的接口名字比较复杂, 而不易使用.</span><br><span class="line"></span><br><span class="line">    如果tcpdump编译时所依赖的libpcap库太老,-D 选项不会被支持, 因为其中缺乏 pcap_findalldevs()函数.</span><br><span class="line"></span><br><span class="line">-e  每行的打印输出中将包括数据包的数据链路层头部信息</span><br><span class="line"></span><br><span class="line">-E  spi@ipaddr algo:secret,...</span><br><span class="line"></span><br><span class="line">    可通过spi@ipaddr algo:secret 来解密IPsec ESP包(nt | rt:IPsec Encapsulating Security Payload,IPsec 封装安全负载, IPsec可理解为, 一整套对ip数据包的加密协议, ESP 为整个IP 数据包或其中上层协议部分被加密后的数据,前者的工作模式称为隧道模式; 后者的工作模式称为传输模式 . 工作原理, 另需补充).</span><br><span class="line"></span><br><span class="line">    需要注意的是, 在终端启动tcpdump 时, 可以为IPv4 ESP packets 设置密钥(secret）.</span><br><span class="line"></span><br><span class="line">    可用于加密的算法包括des-cbc, 3des-cbc, blowfish-cbc, rc3-cbc, cast128-cbc, 或者没有(none).默认的是des-cbc(nt: des, Data Encryption Standard, 数据加密标准, 加密算法未知, 另需补充).secret 为用于ESP 的密钥, 使用ASCII 字符串方式表达. 如果以 0x 开头, 该密钥将以16进制方式读入.</span><br><span class="line"></span><br><span class="line">    该选项中ESP 的定义遵循RFC2406, 而不是 RFC1827. 并且, 此选项只是用来调试的, 不推荐以真实密钥(secret)来使用该选项, 因为这样不安全: 在命令行中输入的secret 可以被其他人通过ps 等命令查看到.</span><br><span class="line"></span><br><span class="line">    除了以上的语法格式(nt: 指spi@ipaddr algo:secret), 还可以在后面添加一个语法输入文件名字供tcpdump 使用(nt：即把spi@ipaddr algo:secret,... 中...换成一个语法文件名). 此文件在接受到第一个ESP　包时会打开此文件, 所以最好此时把赋予tcpdump 的一些特权取消(nt: 可理解为, 这样防范之后, 当该文件为恶意编写时,不至于造成过大损害).</span><br><span class="line"></span><br><span class="line">-f  显示外部的IPv4 地址时(nt: foreign IPv4 addresses, 可理解为, 非本机ip地址), 采用数字方式而不是名字.(此选项是用来对付Sun公司的NIS服务器的缺陷(nt: NIS, 网络信息服务, tcpdump 显示外部地址的名字时会用到她提供的名称服务): 此NIS服务器在查询非本地地址名字时,常常会陷入无尽的查询循环).</span><br><span class="line"></span><br><span class="line">    由于对外部(foreign)IPv4地址的测试需要用到本地网络接口(nt: tcpdump 抓包时用到的接口)及其IPv4 地址和网络掩码. 如果此地址或网络掩码不可用, 或者此接口根本就没有设置相应网络地址和网络掩码(nt: linux 下的 &#39;any&#39; 网络接口就不需要设置地址和掩码, 不过此&#39;any&#39;接口可以收到系统中所有接口的数据包), 该选项不能正常工作.</span><br><span class="line"></span><br><span class="line">-F  file</span><br><span class="line">    使用file 文件作为过滤条件表达式的输入, 此时命令行上的输入将被忽略.</span><br><span class="line"></span><br><span class="line">-i  interface</span><br><span class="line"></span><br><span class="line">    指定tcpdump 需要监听的接口.  如果没有指定, tcpdump 会从系统接口列表中搜寻编号最小的已配置好的接口(不包括 loopback 接口).一但找到第一个符合条件的接口, 搜寻马上结束.</span><br><span class="line"></span><br><span class="line">    在采用2.2版本或之后版本内核的Linux 操作系统上, &#39;any&#39; 这个虚拟网络接口可被用来接收所有网络接口上的数据包(nt: 这会包括目的是该网络接口的, 也包括目的不是该网络接口的). 需要注意的是如果真实网络接口不能工作在&#39;混杂&#39;模式(promiscuous)下,则无法在&#39;any&#39;这个虚拟的网络接口上抓取其数据包.</span><br><span class="line"></span><br><span class="line">    如果 -D 标志被指定, tcpdump会打印系统中的接口编号，而该编号就可用于此处的interface 参数.</span><br><span class="line"></span><br><span class="line">-l  对标准输出进行行缓冲(nt: 使标准输出设备遇到一个换行符就马上把这行的内容打印出来).在需要同时观察抓包打印以及保存抓包记录的时候很有用. 比如, 可通过以下命令组合来达到此目的:</span><br><span class="line">    &#96;&#96;tcpdump  -l  |  tee dat&#39;&#39; 或者 &#96;&#96;tcpdump  -l   &gt; dat  &amp;  tail  -f  dat&#39;&#39;.(nt: 前者使用tee来把tcpdump 的输出同时放到文件dat和标准输出中, 而后者通过重定向操作&#39;&gt;&#39;, 把tcpdump的输出放到dat 文件中, 同时通过tail把dat文件中的内容放到标准输出中)</span><br><span class="line"></span><br><span class="line">-L  列出指定网络接口所支持的数据链路层的类型后退出.(nt: 指定接口通过-i 来指定)</span><br><span class="line"></span><br><span class="line">-m  module</span><br><span class="line">    通过module 指定的file 装载SMI MIB 模块(nt: SMI，Structure of Management Information, 管理信息结构MIB, Management Information Base, 管理信息库. 可理解为, 这两者用于SNMP(Simple Network Management Protoco)协议数据包的抓取. 具体SNMP 的工作原理未知, 另需补充).</span><br><span class="line"></span><br><span class="line">    此选项可多次使用, 从而为tcpdump 装载不同的MIB 模块.</span><br><span class="line"></span><br><span class="line">-M  secret  如果TCP 数据包(TCP segments)有TCP-MD5选项(在RFC 2385有相关描述), 则为其摘要的验证指定一个公共的密钥secret.</span><br><span class="line"></span><br><span class="line">-n  不对地址(比如, 主机地址, 端口号)进行数字表示到名字表示的转换.</span><br><span class="line"></span><br><span class="line">-N  不打印出host 的域名部分. 比如, 如果设置了此选现, tcpdump 将会打印&#39;nic&#39; 而不是 &#39;nic.ddn.mil&#39;.</span><br><span class="line"></span><br><span class="line">-O  不启用进行包匹配时所用的优化代码. 当怀疑某些bug是由优化代码引起的, 此选项将很有用.</span><br><span class="line"></span><br><span class="line">-p  一般情况下, 把网络接口设置为非&#39;混杂&#39;模式. 但必须注意 , 在特殊情况下此网络接口还是会以&#39;混杂&#39;模式来工作； 从而, &#39;-p&#39; 的设与不设, 不能当做以下选现的代名词:&#39;ether host &#123;local-hw-add&#125;&#39; 或  &#39;ether broadcast&#39;(nt: 前者表示只匹配以太网地址为host 的包, 后者表示匹配以太网地址为广播地址的数据包).</span><br><span class="line"></span><br><span class="line">-q  快速(也许用&#39;安静&#39;更好?)打印输出. 即打印很少的协议相关信息, 从而输出行都比较简短.</span><br><span class="line"></span><br><span class="line">-R  设定tcpdump 对 ESP&#x2F;AH 数据包的解析按照 RFC1825而不是RFC1829(nt: AH, 认证头, ESP， 安全负载封装, 这两者会用在IP包的安全传输机制中). 如果此选项被设置, tcpdump 将不会打印出&#39;禁止中继&#39;域(nt: relay prevention field). 另外,由于ESP&#x2F;AH规范中没有规定ESP&#x2F;AH数据包必须拥有协议版本号域,所以tcpdump不能从收到的ESP&#x2F;AH数据包中推导出协议版本号.</span><br><span class="line"></span><br><span class="line">-r  file</span><br><span class="line">    从文件file 中读取包数据. 如果file 字段为 &#39;-&#39; 符号, 则tcpdump 会从标准输入中读取包数据.</span><br><span class="line"></span><br><span class="line">-S  打印TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号.(nt: 相对顺序号可理解为, 相对第一个TCP 包顺序号的差距,比如, 接受方收到第一个数据包的绝对顺序号为232323, 对于后来接收到的第2个,第3个数据包, tcpdump会打印其序列号为1, 2分别表示与第一个数据包的差距为1 和 2. 而如果此时-S 选项被设置, 对于后来接收到的第2个, 第3个数据包会打印出其绝对顺序号:232324, 232325).</span><br><span class="line"></span><br><span class="line">-s  snaplen</span><br><span class="line">    设置tcpdump的数据包抓取长度为snaplen, 如果不设置默认将会是68字节(而支持网络接口分接头(nt: NIT, 上文已有描述,可搜索&#39;网络接口分接头&#39;关键字找到那里)的SunOS系列操作系统中默认的也是最小值是96).68字节对于IP, ICMP(nt: Internet Control Message Protocol,因特网控制报文协议), TCP 以及 UDP 协议的报文已足够, 但对于名称服务(nt: 可理解为dns, nis等服务), NFS服务相关的数据包会产生包截短. 如果产生包截短这种情况, tcpdump的相应打印输出行中会出现&#39;&#39;[|proto]&#39;&#39;的标志（proto 实际会显示为被截短的数据包的相关协议层次). 需要注意的是, 采用长的抓取长度(nt: snaplen比较大), 会增加包的处理时间, 并且会减少tcpdump 可缓存的数据包的数量， 从而会导致数据包的丢失. 所以, 在能抓取我们想要的包的前提下, 抓取长度越小越好.把snaplen 设置为0 意味着让tcpdump自动选择合适的长度来抓取数据包.</span><br><span class="line"></span><br><span class="line">-T  type</span><br><span class="line">    强制tcpdump按type指定的协议所描述的包结构来分析收到的数据包.  目前已知的type 可取的协议为:</span><br><span class="line">    aodv (Ad-hoc On-demand Distance Vector protocol, 按需距离向量路由协议, 在Ad hoc(点对点模式)网络中使用),</span><br><span class="line">    cnfp (Cisco  NetFlow  protocol),  rpc(Remote Procedure Call), rtp (Real-Time Applications protocol),</span><br><span class="line">    rtcp (Real-Time Applications con-trol protocol), snmp (Simple Network Management Protocol),</span><br><span class="line">    tftp (Trivial File Transfer Protocol, 碎文件协议), vat (Visual Audio Tool, 可用于在internet 上进行电</span><br><span class="line">    视电话会议的应用层协议), 以及wb (distributed White Board, 可用于网络会议的应用层协议).</span><br><span class="line"></span><br><span class="line">-t     在每行输出中不打印时间戳</span><br><span class="line"></span><br><span class="line">-tt    不对每行输出的时间进行格式处理(nt: 这种格式一眼可能看不出其含义, 如时间戳打印成1261798315)</span><br><span class="line"></span><br><span class="line">-ttt   tcpdump 输出时, 每两行打印之间会延迟一个段时间(以毫秒为单位)</span><br><span class="line"></span><br><span class="line">-tttt  在每行打印的时间戳之前添加日期的打印</span><br><span class="line"></span><br><span class="line">-u     打印出未加密的NFS 句柄(nt: handle可理解为NFS 中使用的文件句柄, 这将包括文件夹和文件夹中的文件)</span><br><span class="line"></span><br><span class="line">-U    使得当tcpdump在使用-w 选项时, 其文件写入与包的保存同步.(nt: 即, 当每个数据包被保存时, 它将及时被写入文件中,而不是等文件的输出缓冲已满时才真正写入此文件)</span><br><span class="line"></span><br><span class="line">      -U 标志在老版本的libcap库(nt: tcpdump 所依赖的报文捕获库)上不起作用, 因为其中缺乏pcap_cump_flush()函数.</span><br><span class="line"></span><br><span class="line">-v    当分析和打印的时候, 产生详细的输出. 比如, 包的生存时间, 标识, 总长度以及IP包的一些选项. 这也会打开一些附加的包完整性检测, 比如对IP或ICMP包头部的校验和.</span><br><span class="line"></span><br><span class="line">-vv   产生比-v更详细的输出. 比如, NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码.</span><br><span class="line"></span><br><span class="line">-vvv  产生比-vv更详细的输出. 比如, telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面,</span><br><span class="line">      其相应的图形选项将会以16进制的方式打印出来(nt: telnet 的SB,SE选项含义未知, 另需补充).</span><br><span class="line"></span><br><span class="line">-w    把包数据直接写入文件而不进行分析和打印输出. 这些包数据可在随后通过-r 选项来重新读入并进行分析和打印.</span><br><span class="line"></span><br><span class="line">-W    filecount</span><br><span class="line">      此选项与-C 选项配合使用, 这将限制可打开的文件数目, 并且当文件数据超过这里设置的限制时, 依次循环替代之前的文件, 这相当于一个拥有filecount 个文件的文件缓冲池. 同时, 该选项会使得每个文件名的开头会出现足够多并用来占位的0, 这可以方便这些文件被正确的排序.</span><br><span class="line"></span><br><span class="line">-x    当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据(但不包括连接层的头部).总共打印的数据大小不会超过整个数据包的大小与snaplen 中的最小值. 必须要注意的是, 如果高层协议数据没有snaplen 这么长,并且数据链路层(比如, Ethernet层)有填充数据, 则这些填充数据也会被打印.(nt: so for link  layers  that pad, 未能衔接理解和翻译, 需补充 )</span><br><span class="line"></span><br><span class="line">-xx   tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部.</span><br><span class="line"></span><br><span class="line">-X    当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据(但不包括连接层的头部).这对于分析一些新协议的数据包很方便.</span><br><span class="line"></span><br><span class="line">-XX   当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据, 其中包括数据链路层的头部.这对于分析一些新协议的数据包很方便.</span><br><span class="line"></span><br><span class="line">-y    datalinktype</span><br><span class="line">      设置tcpdump 只捕获数据链路层协议类型是datalinktype的数据包</span><br><span class="line"></span><br><span class="line">-Z    user</span><br><span class="line">      使tcpdump 放弃自己的超级权限(如果以root用户启动tcpdump, tcpdump将会有超级用户权限), 并把当前tcpdump的用户ID设置为user, 组ID设置为user首要所属组的ID(nt: tcpdump 此处可理解为tcpdump 运行之后对应的进程)</span><br><span class="line"></span><br><span class="line">      此选项也可在编译的时候被设置为默认打开.(nt: 此时user 的取值未知, 需补充)</span><br></pre></td></tr></table></figure>

<h2 id="实用命令实例"><a href="#实用命令实例" class="headerlink" title="实用命令实例"></a>实用命令实例</h2><h3 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump</span><br></pre></td></tr></table></figure>

<p>普通情况下，直接启动 tcpdump 将监视第一个网络接口(网卡)上所有流过的数据包。</p>
<h3 id="监视指定网络接口的数据包"><a href="#监视指定网络接口的数据包" class="headerlink" title="监视指定网络接口的数据包"></a>监视指定网络接口的数据包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1</span><br></pre></td></tr></table></figure>

<p>如果不指定网卡，默认 tcpdump 只会监视第一个网络接口，一般是 eth0，下面的例子都没有指定网络接口。</p>
<h3 id="监视指定主机的数据包"><a href="#监视指定主机的数据包" class="headerlink" title="监视指定主机的数据包"></a>监视指定主机的数据包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host sundown</span><br></pre></td></tr></table></figure>

<p>过滤出所有进入或离开域名为：ccinn 的数据包.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 210.27.48.10</span><br></pre></td></tr></table></figure>

<p>也可以指定 ip,例如截获所有 210.27.48.10 的主机收到的和发出的所有的数据包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host ccinn and \( baa or bee \)</span><br></pre></td></tr></table></figure>

<p>过滤出域名为 ccinn 与 baa 或者与 bee 之间通信的数据包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \)</span><br></pre></td></tr></table></figure>

<p>同域名的原理，截获主机 IP 210.27.48.1 和主机 IP 210.27.48.2 或 210.27.48.3 的通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump ip host ace and not helios</span><br></pre></td></tr></table></figure>

<p>打印 ace 与任何其他主机之间通信的 <code>IP 数据包</code>, 但不包括与 helios 之间的数据包.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump ip host 210.27.48.1 and ! 210.27.48.2</span><br></pre></td></tr></table></figure>

<p>如果想要获取主机 210.27.48.1 除了和主机 210.27.48.2 之外所有主机通信的 ip 包.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 src host ccinn.com</span><br></pre></td></tr></table></figure>

<p>截获主机 ccinn.com 发送的所有数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 dst host ccinn.com</span><br></pre></td></tr></table></figure>

<p>截获主机 ccinn.com 接收的所有数据</p>
<h3 id="监视指定主机和端口的数据包"><a href="#监视指定主机和端口的数据包" class="headerlink" title="监视指定主机和端口的数据包"></a>监视指定主机和端口的数据包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump tcp port 23 and host 210.27.48.1</span><br></pre></td></tr></table></figure>

<p>如果想要获取主机 210.27.48.1 并且端口为 23 的接收或发出的 tcp 包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump udp port 123</span><br></pre></td></tr></table></figure>

<p>对本机的 udp 123 端口进行过滤</p>
<h3 id="监视指定协议的数据包"><a href="#监视指定协议的数据包" class="headerlink" title="监视指定协议的数据包"></a>监视指定协议的数据包</h3><p>这个是灵活度比较高的用法，需要我们对底层协议有一定了解才比较好处理。这里会用 TCP 协议作为例子。<br>如果对 TCP 协议不了解的话，这个高级用法可能派不上用场。</p>
<p>下面详细介绍proto [ expr : size]</p>
<p>Proto即protocol的缩写，它表示这里要指定的是某种协议名称，如ip,tcp,udp等。总之可以指定的协议有十多种，如链路层协议 ether,fddi,tr,wlan,ppp,slip,link,</p>
<p>网络层协议ip,ip6,arp,rarp,icmp传输层协议tcp,udp等。</p>
<p>expr用来指定数据报字节单位的偏移量，该偏移量相对于指定的协议层，默认的起始位置是0；而size表示从偏移量的位置开始提取多少个字节，可以设置为</p>
<p>1、2、4,默认为1字节。如果只设置了expr，而没有设置size，则默认提取1个字节。比如ip[2:2]，就表示提取出第3、4个字节；而ip[0]则表示提取ip协议头的</p>
<p>第一个字节。在我们提取了特定内容之后，我们就需要设置我们的过滤条件了，我们可用的“比较操作符”包括：&gt;，&lt;，&gt;=，&lt;=，=，!=，总共有6个。</p>
<p>举个例子：抓取带有特殊标志的的 TCP 包(如 SYN-ACK 标志, URG-ACK 标志等).</p>
<p>在 TCP 的头部中, 有 8 比特(bit)用作控制位区域, 其取值为:<br>CWR | ECE | URG | ACK | PSH | RST | SYN | FIN</p>
<p>现假设我们想要监控建立一个 TCP 连接整个过程中所产生的数据包. 可回忆如下:TCP 使用 3 次握手协议来建立一个新的连接; 其与此三次握手<br>连接顺序对应，并带有相应 TCP 控制标志的数据包如下:</p>
<ol>
<li>连接发起方发送 SYN 标志的数据包</li>
<li>接收方用带有 SYN 和 ACK 标志的数据包进行回应</li>
<li>发起方收到接收方回应后再发送带有 ACK 标志的数据包进行回应</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0                            15                              31</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">|          source port          |       destination port        |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">|                        sequence number                        |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">|                     acknowledgment number                     |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">|  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">|         TCP checksum          |       urgent pointer          |</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">| 0             7  | 15                     | 23              | 31               |</span><br><span class="line">| ---------------- | ---------------------- | --------------- | ---------------- |</span><br><span class="line">| HL   \| rsvd     | C\|E\|U\|A\|P\|R\|S\|F | window size     |</span><br><span class="line">| ---------------- | ---------------        | --------------- | ---------------- |</span><br><span class="line">|                  | 13th octet             |                 |                  |</span><br><span class="line"></span><br><span class="line">|C|E|U|A|P|R|S|F|</span><br><span class="line">|---------------|</span><br><span class="line">|0 0 0 0 0 0 1 0|</span><br><span class="line">|---------------|</span><br><span class="line">|7 6 5 4 3 2 1 0|</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/tcp-header-2.webp" alt="TCP协议-2"></p>
<p>我们看回这张图，TCP 头部一般是有 20 个字节的数据，在标志位，也就是第三行开始， 第三行开始的话就已经经过了 12 个字节了，那么向左移动 8bit，就是刚好我们的标志位数据，也就是刚好从第 13 个字节的数据开始，就是我们的标志位数据，标志位一共占用 8 个标志位，SYN 标志位从低往高数，就是第二位，ACK 标志位就是第五位。</p>
<p>所以我们的表达式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( ( value of octet 13 ) AND ( 2 ) ) &#x3D;&#x3D; ( 2 )</span><br></pre></td></tr></table></figure>

<p>也就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -iany &#39;tcp[13] &amp; 2 &#x3D;&#x3D; 2&#39;</span><br></pre></td></tr></table></figure>

<p>这个命令就是获取TCP协议中数据包中代表SYN消息的数据。</p>
<p>这样子，我们捕捉到的就是只有如下消息，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@8152f1016ea8:&#x2F;data# tcpdump -iany &#39;tcp port 6379 and tcp[13] &amp; 2 &#x3D;&#x3D; 2&#39;</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</span><br><span class="line">10:06:37.491460 IP localhost.34716 &gt; localhost.6379: Flags [S], seq 998071933, win 43690, options [mss 65495,sackOK,TS val 11418013 ecr 0,nop,wscale 7], length 0</span><br><span class="line">10:06:37.491501 IP localhost.6379 &gt; localhost.34716: Flags [S.], seq 2636200817, ack 998071934, win 43690, options [mss 65495,sackOK,TS val 11418013 ecr 11418013,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure>

<p>全部都是带有[S]标志的。</p>
<h3 id="使用-tcpdump-抓取-HTTP-包"><a href="#使用-tcpdump-抓取-HTTP-包" class="headerlink" title="使用 tcpdump 抓取 HTTP 包"></a>使用 tcpdump 抓取 HTTP 包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -XvvennSs 0 -i eth0 tcp[20:2]&#x3D;0x4745 or tcp[20:2]&#x3D;0x4854</span><br></pre></td></tr></table></figure>

<p>0x4745 为”GET”前两个字母”GE”,0x4854 为”HTTP”前两个字母”HT”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>tcpdump 对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w 参数的 tcpdump 截获数据并保存到文件中保存成 cap 文件，然后再使用其他程序(如 Wireshark)进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。</p>
<p>如果需要最完整对说明对话，可以参考官网说明<a href="https://www.tcpdump.org/manpages/tcpdump.1.html" target="_blank" rel="noopener">tcpdump</a>.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/网络协议/">网络协议</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/TCP/">TCP</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 白菜(whiteCcinn)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>