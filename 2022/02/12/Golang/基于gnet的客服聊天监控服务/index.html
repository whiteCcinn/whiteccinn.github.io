<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>【Golang】- 基于gnet的端口复用支持多协议的客服聊天监控服务 | 白菜君の技术库</title>

  
  <meta name="author" content="白菜(whiteCcinn)">
  

  
  <meta name="description" content="知道做不到，等于不知道">
  

  
  <meta name="keywords" content="白菜,文辉,技术博客,whiteCcinn">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="【Golang】- 基于gnet的端口复用支持多协议的客服聊天监控服务"/>

  <meta property="og:site_name" content="白菜君の技术库"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="白菜君の技术库" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">白菜君の技术库</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/">文章</a></li>
      
        <li><a href="/tags/">标签</a></li>
      
        <li><a href="/categories/">分类</a></li>
      
        <li><a href="/about/">关于我</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>【Golang】- 基于gnet的端口复用支持多协议的客服聊天监控服务</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/02/12/Golang/基于gnet的客服聊天监控服务/" rel="bookmark">
        <time class="entry-date published" datetime="2022-02-11T16:46:51.000Z">
          2022-02-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近，公司以前有一些旧的服务，由于各种原因，导致各种问题，并且架构设计行也不是那么友好和不利于维护。<br>所以准备重构设计一些服务。</p>
<p>在游戏公司中，GM客服的其中一个职能就是监督舆论，从玩家平日的聊天中进行监控。</p>
<p>我们从<code>业务需求</code>+<code>技术架构</code>层面进行整理。</p>
<a id="more"></a>

<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>在过去中，由于当时php还是如日中天，旧的则是采集的<code>swoole1.x</code>的版本进行开发的服务。<br>受限于php一个语言特性，注定无法实现一些高性能的中间件，或者说大数据生态十分欠缺。当时用php除了<code>fastcgi</code>的<code>web系统</code>外，最多就只能做一些基本的<code>常驻</code>任务。</p>
<p>消息中间件最多也就是用到<code>rabbitmq</code>，<code>rocketmq</code>等等。</p>
<p>而常驻，一般无非就是直接<code>cli</code>，外加一个<code>循环+sleep</code>的组合套餐。而要实现<code>websocket-server</code>这种常驻服务，一般是借助<code>swoole</code>来处理。毕竟<code>reactor</code>的模式，怎么都比<code>单进程</code>的实现好。</p>
<p>分为了3个模块（每个模块=每个角色=一个进程=一个服务）：</p>
<ul>
<li>chat_record （聊天记录角色）（weboccket_client, tcp_clinet）</li>
<li>db_server （数据层角色) (tcp_server)</li>
<li>websocket_server (连接层角色) (webocket_server)</li>
</ul>
<p>由于当时php基本无法多线程编程(可用，但是不友好)，只能采用这种委婉的<code>伪多进程</code>的模拟进行<code>不同任务的处理</code>和<code>数据的交互</code>。</p>
<p><img src="/images/Go/chat_monitor.png" alt="旧服务的数据流图"></p>
<h2 id="新服务"><a href="#新服务" class="headerlink" title="新服务"></a>新服务</h2><p><img src="/images/Go/chat_monitor_new.png" alt="新服务的数据流图"></p>
<blockquote>
<p>但是由于种种原因，后面并未如此拆分架构，而是将<code>websocket-server网络连接层</code>的和<code>业务层</code>合并成为了一个<code>单体服务</code></p>
</blockquote>
<p>技术选型上</p>
<ul>
<li>go</li>
<li>gnet</li>
<li>kafka</li>
</ul>
<h3 id="为什么核心的网络层需要采用gnet呢？"><a href="#为什么核心的网络层需要采用gnet呢？" class="headerlink" title="为什么核心的网络层需要采用gnet呢？"></a>为什么核心的网络层需要采用<code>gnet</code>呢？</h3><p>一般Go语言的TCP(和HTTP)的处理都是<code>每一个连接</code>启动<code>一个goroutine</code>去处理，因为我们被教导<code>goroutine</code>的不像<code>thread</code>, 它是很便宜的，可以在服务器上启动成<code>千上万的goroutine</code>。</p>
<p>但是对于<code>一百万</code>的连接，这种<code>goroutine-per-connection</code>的模式就<code>至少</code>要启动<code>一百万个goroutine</code>，这对资源的消耗也是极大的。</p>
<p>针对不同的操作系统和不同的Go版本，一个goroutine锁使用的最小的栈大小是<code>2KB ~ 8 KB (go stack)</code>,如果在每个goroutine中在<code>分配byte buffer</code>用以从连接中读写数据，<code>几十G的内存</code>轻轻松松就分配出去了。</p>
<p><code>吞吐率</code>和<code>延迟</code>需要数据来支撑，但是显然这个<code>单goroutine</code>处理的模式<code>不适合耗时较长</code>的业务处理，<code>&quot;hello world&quot;</code>或者<code>直接的简单的memory操作</code>应该没有问题。</p>
<p>对于百万连接<code>但是并发量很小</code>的场景，比如消息推送、页游等场景，这种实现应该是没有问题的。</p>
<p>但是对于并发量很大，延迟要求比较低的场景，这种实现可能会存在问题。</p>
<p><code>gnet</code>采用了类似<code>netty</code>的<code>reactor</code>模式，基于<code>epoll</code>或者<code>kqueue</code>实现io多路复用。并且基于golang的语言特性，其实现原理为<code>带线程/go程池的主从 Reactors 多线程</code>模式，在网络层上性能上有极大的优化。</p>
<p>我们通过gnet提供的tcp网络层，在应用层，实现了http和webocket的端口复用的形式。</p>
<p>http用于提供<code>prometheus</code>的<code>metrics</code>指标，例如<code>连接数/各种类型引发的error数/每条数据被多少个GM客服监视着</code>等等</p>
<p>websocket则是用于在我们的<code>GM客服</code>中，提一个实时的聊天数据获取</p>
<h3 id="为什么采用kafka"><a href="#为什么采用kafka" class="headerlink" title="为什么采用kafka"></a>为什么采用kafka</h3><p>由于我们整套日志服务都是基于kafka作为核心组件的，所以在数据的实时上，可以保证到数据的实效性。</p>
<p>从而取消了以往从mysql中分库分表去查询数据。也不需要通过其他<code>OLAP</code>的服务进行处理。</p>
<h3 id="端口复用实现支持多协议"><a href="#端口复用实现支持多协议" class="headerlink" title="端口复用实现支持多协议"></a>端口复用实现支持多协议</h3><p>这个是网络连接层，也是链接的核心业务逻辑，在gnet中当有数据到来的时候，由<code>IO多路复用</code>的<code>epoll</code>模型，会触发<code>OnTraffic(c gnet.Conn)</code>的回调函数，在这个过程中，我们就可以通过网络层中获取的数据进行加工处理，形成自己想要的<code>应用协议</code>。</p>
<p>由于刚才介绍到了，我们需要实现核心需求：<code>端口多协议复用</code></p>
<p>在这里，先列出核心的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> ApplicationLayerProto <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(alp ApplicationLayerProto)</span> <span class="title">String</span><span class="params">()</span> <span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> alp &#123;</span><br><span class="line">	<span class="keyword">case</span> HttpApplicationLayerProto:</span><br><span class="line">		s = <span class="string">"http"</span></span><br><span class="line">	<span class="keyword">case</span> WebsocketApplicationLayerProto:</span><br><span class="line">		s = <span class="string">"websocket"</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		s = <span class="string">"unknown"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	HttpApplicationLayerProto ApplicationLayerProto = <span class="literal">iota</span></span><br><span class="line">	WebsocketApplicationLayerProto</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> codec <span class="keyword">struct</span> &#123;</span><br><span class="line">	proto ApplicationLayerProto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *codec)</span> <span class="title">isHttp</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.proto == HttpApplicationLayerProto &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *codec)</span> <span class="title">isWebsocket</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.proto == WebsocketApplicationLayerProto &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> httpCodec <span class="keyword">struct</span> &#123;</span><br><span class="line">	*codec</span><br><span class="line">	parser *wildcat.HTTPParser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> wsCodec <span class="keyword">struct</span> &#123;</span><br><span class="line">	*codec</span><br><span class="line">	connected <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(serv *server)</span> <span class="title">OnOpen</span><span class="params">(c gnet.Conn)</span> <span class="params">([]<span class="keyword">byte</span>, gnet.Action)</span></span> &#123;</span><br><span class="line">	c.SetContext(<span class="built_in">new</span>(codec))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, gnet.None</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(serv *server)</span> <span class="title">OnTraffic</span><span class="params">(c gnet.Conn)</span> <span class="title">gnet</span>.<span class="title">Action</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer *bytes.Buffer</span><br><span class="line">	<span class="keyword">var</span> buff []<span class="keyword">byte</span></span><br><span class="line">pipeline:</span><br><span class="line">	<span class="keyword">switch</span> cdc := c.Context().(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *codec:</span><br><span class="line">		buf, err := c.Next(<span class="number">-1</span>)</span><br><span class="line">		buff = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(buf))</span><br><span class="line">		<span class="built_in">copy</span>(buff, buf)</span><br><span class="line">		buffer = bytes.NewBuffer(buff)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gnet.Close</span><br><span class="line">		&#125;</span><br><span class="line">		hc := &amp;httpCodec&#123;parser: wildcat.NewHTTPParser(), codec: cdc&#125;</span><br><span class="line">		_, err = hc.parser.Parse(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Errorlog(log.NetServerErrorCategory&#123;Summary: fmt.Sprintf(<span class="string">"http parser error: %v"</span>, err)&#125;)</span><br><span class="line">			<span class="keyword">return</span> gnet.Close</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> upgrade := hc.parser.FindHeader([]<span class="keyword">byte</span>(<span class="string">"Upgrade"</span>)); upgrade != <span class="literal">nil</span> &amp;&amp; bytes.Equal(upgrade, []<span class="keyword">byte</span>(<span class="string">"websocket"</span>)) &#123;</span><br><span class="line">			cdc.proto = WebsocketApplicationLayerProto</span><br><span class="line">			wc := &amp;wsCodec&#123;</span><br><span class="line">				codec: cdc,</span><br><span class="line">			&#125;</span><br><span class="line">			c.SetContext(wc)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cdc.proto = HttpApplicationLayerProto</span><br><span class="line">			c.SetContext(hc)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> pipeline</span><br><span class="line">	<span class="keyword">case</span> *httpCodec:</span><br><span class="line">		buf := bufio.NewReader(buffer)</span><br><span class="line">		req, err := http.ReadRequest(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Errorlog(log.NetServerErrorCategory&#123;Summary: fmt.Sprintf(<span class="string">"request from http error: %v"</span>, err)&#125;)</span><br><span class="line">			<span class="keyword">return</span> gnet.Close</span><br><span class="line">		&#125;</span><br><span class="line">		metrics.TotalConnectedCounter.WithLabelValues(HttpApplicationLayerProto.String()).Inc()</span><br><span class="line">		resp := route.NewResponse(c)</span><br><span class="line">		h, _ := serv.serverMux.Handler(req)</span><br><span class="line">		h.ServeHTTP(resp, req)</span><br><span class="line">		<span class="keyword">if</span> _, err = resp.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Errorlog(log.NetServerErrorCategory&#123;Summary: fmt.Sprintf(<span class="string">"write to http error: %v"</span>, err)&#125;)</span><br><span class="line">			<span class="keyword">return</span> gnet.Close</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> gnet.Close</span><br><span class="line">	<span class="keyword">case</span> *wsCodec:</span><br><span class="line">		<span class="keyword">if</span> !cdc.connected &#123;</span><br><span class="line">			wcb := &amp;wsConnBridge&#123;</span><br><span class="line">				buff: buffer,</span><br><span class="line">				c:    c,</span><br><span class="line">			&#125;</span><br><span class="line">			_, err := ws.Upgrade(wcb)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Errorlog(log.NetServerErrorCategory&#123;Summary: fmt.Sprintf(<span class="string">"upgrade[%s] to websocket error: %v"</span>, c.RemoteAddr().String(), err)&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			log.Debugf(log.NetServerDebugCategory&#123;&#125;, <span class="string">"conn[%v] upgrade websocket protocol"</span>, c.RemoteAddr().String())</span><br><span class="line">			cdc.connected = <span class="literal">true</span></span><br><span class="line">			metrics.ConnectedGauge.Inc()</span><br><span class="line">			metrics.TotalConnectedCounter.WithLabelValues(WebsocketApplicationLayerProto.String()).Inc()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			msg, op, err := wsutil.ReadClientData(c)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> _, ok := err.(wsutil.ClosedError); !ok &#123;</span><br><span class="line">					log.Errorlog(log.NetServerErrorCategory&#123;Summary: fmt.Sprintf(<span class="string">"[%s] receive ws message error: %v"</span>, c.RemoteAddr().String(), err)&#125;)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> gnet.Close</span><br><span class="line">			&#125;</span><br><span class="line">			log.Debugf(log.NetServerDebugCategory&#123;&#125;, <span class="string">"conn[%v] receive [op=%v] [msg=%v]"</span>, c.RemoteAddr().String(), op, <span class="keyword">string</span>(msg))</span><br><span class="line">			<span class="keyword">if</span> op == ws.OpText &#123;</span><br><span class="line">				<span class="keyword">if</span> rs := route.MatchRequestSpec(msg); rs == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> route.GlobalWsRouter.DefaultHandler().ServeWebsocket(<span class="string">"/"</span>, msg, c, op)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> route.GlobalWsRouter.MatchHandler(rs.Path).ServeWebsocket(rs.Path, rs.Params, c, op)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> gnet.None</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们可以看到，当存在新链接进来的啥时候，首先经过<code>OnOpen(c gnet.Conn)</code>方法，这个时候，我们会在<code>gnet.Conn</code>中设置一个我们用户的一个<code>上下文环境Context</code>，在这个Context下，我们为每个连接都初始化了<code>codec</code>的结构体对象，当开始接收数据的时候，触发到了<code>OnTraffic(c gnet.Conn)</code>方法，这个以后，我们需要把网络层接收到的数据拿出来，由于<code>流</code>的存在，使得我们无法重复在同一个连接中，多次重复获取流，所以如果后面需要用到的话，利用取出来的<code>byte-buffer</code>生成一个新的<code>流</code>，以供后续使用。</p>
<p>所以你会发现有一段代码为:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf, err := c.Next(<span class="number">-1</span>)</span><br><span class="line">buff = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(buf))</span><br><span class="line"><span class="built_in">copy</span>(buff, buf)</span><br><span class="line">buffer = bytes.NewBuffer(buff)</span><br></pre></td></tr></table></figure>

<p>接下来，需要做的事情就是解析数据为http协议对象，由于我这里的<code>端口复用</code>的逻辑是<code>http+webocket</code>复用，所以都是基于<code>http协议</code>的，所以这里可以简单粗暴的处理，然后通过判断<code>http协议</code>中是否包含了需要升级为<code>webocket协议</code>的关键字段<code>Upgrade:webocket</code>，如果包含，则表示本次请求是一个websocket连接，否则就是一个单纯http连接。以此来达到复用的需求。</p>
<p>在这个基础之上，我们也更新了当前连接的<code>上下文环境Context</code>，升级为了<code>httpCodec</code>和<code>wsCodec</code>，通过<code>goto+断言</code>语法，我们可以进入到，我们所需要进入的逻辑阶段。不要觉得这就完事了，麻烦的事情才刚开始，现在你只是知道了开头。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buf := bufio.NewReader(buffer)</span><br><span class="line">req, err := http.ReadRequest(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Errorlog(log.NetServerErrorCategory&#123;Summary: fmt.Sprintf(<span class="string">"request from http error: %v"</span>, err)&#125;)</span><br><span class="line">    <span class="keyword">return</span> gnet.Close</span><br><span class="line">&#125;</span><br><span class="line">metrics.TotalConnectedCounter.WithLabelValues(HttpApplicationLayerProto.String()).Inc()</span><br><span class="line">resp := route.NewResponse(c)</span><br><span class="line">h, _ := serv.serverMux.Handler(req)</span><br><span class="line">h.ServeHTTP(resp, req)</span><br><span class="line"><span class="keyword">if</span> _, err = resp.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Errorlog(log.NetServerErrorCategory&#123;Summary: fmt.Sprintf(<span class="string">"write to http error: %v"</span>, err)&#125;)</span><br><span class="line">    <span class="keyword">return</span> gnet.Close</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gnet.Close</span><br></pre></td></tr></table></figure>


<p>如果是<code>http协议</code>，那么我们就不需要升级协议了。但是有一个问题就是，在golang的<code>http/server.go</code>中，我们所熟悉的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Handler responds to an HTTP request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ServeHTTP should write reply headers and data to the ResponseWriter</span></span><br><span class="line"><span class="comment">// and then return. Returning signals that the request is finished; it</span></span><br><span class="line"><span class="comment">// is not valid to use the ResponseWriter or read from the</span></span><br><span class="line"><span class="comment">// Request.Body after or concurrently with the completion of the</span></span><br><span class="line"><span class="comment">// ServeHTTP call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Depending on the HTTP client software, HTTP protocol version, and</span></span><br><span class="line"><span class="comment">// any intermediaries between the client and the Go server, it may not</span></span><br><span class="line"><span class="comment">// be possible to read from the Request.Body after writing to the</span></span><br><span class="line"><span class="comment">// ResponseWriter. Cautious handlers should read the Request.Body</span></span><br><span class="line"><span class="comment">// first, and then reply.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Except for reading the body, handlers should not modify the</span></span><br><span class="line"><span class="comment">// provided Request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes</span></span><br><span class="line"><span class="comment">// that the effect of the panic was isolated to the active request.</span></span><br><span class="line"><span class="comment">// It recovers the panic, logs a stack trace to the server error log,</span></span><br><span class="line"><span class="comment">// and either closes the network connection or sends an HTTP/2</span></span><br><span class="line"><span class="comment">// RST_STREAM, depending on the HTTP protocol. To abort a handler so</span></span><br><span class="line"><span class="comment">// the client sees an interrupted response but the server doesn't log</span></span><br><span class="line"><span class="comment">// an error, panic with the value ErrAbortHandler.</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到这个<code>Handler</code>interface，需要实现<code>ServeHTTP(ResponseWriter, *Request)</code>，而这个<code>Request</code>，对于我们目前来是，是不存在的，所以我们需要想办法构造一个<code>Request</code>对象出来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadRequest reads and parses an incoming request from b.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ReadRequest is a low-level function and should only be used for</span></span><br><span class="line"><span class="comment">// specialized applications; most code should use the Server to read</span></span><br><span class="line"><span class="comment">// requests and handle them via the Handler interface. ReadRequest</span></span><br><span class="line"><span class="comment">// only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadRequest</span><span class="params">(b *bufio.Reader)</span> <span class="params">(*Request, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> readRequest(b, deleteHostHeader)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好在标准包中提供一个<code>ReadRequest(b *bufio.Reader) (*Request, error)</code>的方法，可以通过<code>bufio.Reader</code>去读取<code>http协议</code>，然后构造出我们所需要的<code>Request</code>对象，所以你会看到，我们在一开始<code>copy(buff, buf)</code>的意义就体现在此了。<br>还会那句话，因为这是一个<code>流</code>，无法重复读取，所以我们利用<code>[]byte</code>构造一个全新的可度的字节流。</p>
<p>解决了<code>Request</code>的问题之后，另外一个问题也来了，<code>ResponseWriter</code>是一个和Response相关可写的字节流。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A ResponseWriter interface is used by an HTTP handler to</span></span><br><span class="line"><span class="comment">// construct an HTTP response.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A ResponseWriter may not be used after the Handler.ServeHTTP method</span></span><br><span class="line"><span class="comment">// has returned.</span></span><br><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Header returns the header map that will be sent by</span></span><br><span class="line">	<span class="comment">// WriteHeader. The Header map also is the mechanism with which</span></span><br><span class="line">	<span class="comment">// Handlers can set HTTP trailers.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Changing the header map after a call to WriteHeader (or</span></span><br><span class="line">	<span class="comment">// Write) has no effect unless the modified headers are</span></span><br><span class="line">	<span class="comment">// trailers.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// There are two ways to set Trailers. The preferred way is to</span></span><br><span class="line">	<span class="comment">// predeclare in the headers which trailers you will later</span></span><br><span class="line">	<span class="comment">// send by setting the "Trailer" header to the names of the</span></span><br><span class="line">	<span class="comment">// trailer keys which will come later. In this case, those</span></span><br><span class="line">	<span class="comment">// keys of the Header map are treated as if they were</span></span><br><span class="line">	<span class="comment">// trailers. See the example. The second way, for trailer</span></span><br><span class="line">	<span class="comment">// keys not known to the Handler until after the first Write,</span></span><br><span class="line">	<span class="comment">// is to prefix the Header map keys with the TrailerPrefix</span></span><br><span class="line">	<span class="comment">// constant value. See TrailerPrefix.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// To suppress automatic response headers (such as "Date"), set</span></span><br><span class="line">	<span class="comment">// their value to nil.</span></span><br><span class="line">	Header() Header</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write writes the data to the connection as part of an HTTP reply.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If WriteHeader has not yet been called, Write calls</span></span><br><span class="line">	<span class="comment">// WriteHeader(http.StatusOK) before writing the data. If the Header</span></span><br><span class="line">	<span class="comment">// does not contain a Content-Type line, Write adds a Content-Type set</span></span><br><span class="line">	<span class="comment">// to the result of passing the initial 512 bytes of written data to</span></span><br><span class="line">	<span class="comment">// DetectContentType. Additionally, if the total size of all written</span></span><br><span class="line">	<span class="comment">// data is under a few KB and there are no Flush calls, the</span></span><br><span class="line">	<span class="comment">// Content-Length header is added automatically.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Depending on the HTTP protocol version and the client, calling</span></span><br><span class="line">	<span class="comment">// Write or WriteHeader may prevent future reads on the</span></span><br><span class="line">	<span class="comment">// Request.Body. For HTTP/1.x requests, handlers should read any</span></span><br><span class="line">	<span class="comment">// needed request body data before writing the response. Once the</span></span><br><span class="line">	<span class="comment">// headers have been flushed (due to either an explicit Flusher.Flush</span></span><br><span class="line">	<span class="comment">// call or writing enough data to trigger a flush), the request body</span></span><br><span class="line">	<span class="comment">// may be unavailable. For HTTP/2 requests, the Go HTTP server permits</span></span><br><span class="line">	<span class="comment">// handlers to continue to read the request body while concurrently</span></span><br><span class="line">	<span class="comment">// writing the response. However, such behavior may not be supported</span></span><br><span class="line">	<span class="comment">// by all HTTP/2 clients. Handlers should read before writing if</span></span><br><span class="line">	<span class="comment">// possible to maximize compatibility.</span></span><br><span class="line">	Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// WriteHeader sends an HTTP response header with the provided</span></span><br><span class="line">	<span class="comment">// status code.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If WriteHeader is not called explicitly, the first call to Write</span></span><br><span class="line">	<span class="comment">// will trigger an implicit WriteHeader(http.StatusOK).</span></span><br><span class="line">	<span class="comment">// Thus explicit calls to WriteHeader are mainly used to</span></span><br><span class="line">	<span class="comment">// send error codes.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The provided code must be a valid HTTP 1xx-5xx status code.</span></span><br><span class="line">	<span class="comment">// Only one header may be written. Go does not currently</span></span><br><span class="line">	<span class="comment">// support sending user-defined 1xx informational headers,</span></span><br><span class="line">	<span class="comment">// with the exception of 100-continue response header that the</span></span><br><span class="line">	<span class="comment">// Server sends automatically when the Request.Body is read.</span></span><br><span class="line">	WriteHeader(statusCode <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>秉着面向接口开发的原则，并且为了更好的兼容第三方的API，所以我们需要实现一个自己的<code>ResponseWriter</code>对象，于是就有了<code>route.NewResponse(c)</code>，这个<code>resp</code>实现了上述的接口.</p>
<p>兼容了<code>promhttp</code>提供的<code>Handler</code>，也兼容了自己的<code>helloworld</code>接口。</p>
<p>接着我们通过<code>cmux</code>进行一个路由匹配，然后调用到对应的<code>ServeHTTP</code>,处理完逻辑之后，在<code>resp</code>的<code>Close()</code>阶段，把缓存区的所有<code>[]byte</code>，推送到连接层，然后通过返回<code>gnet.Close</code>进行网络层的断开，至此，一个简单而完整的<code>http交互流程</code>完毕。</p>
<p>对于<code>Websocket</code>协议来说，要做的事情也是十分繁琐（由于用了开源协议库，相对简化了很多），请先看下面的应用层协议处理逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !cdc.connected &#123;</span><br><span class="line">        wcb := &amp;wsConnBridge&#123;</span><br><span class="line">            buff: buffer,</span><br><span class="line">            c:    c,</span><br><span class="line">        &#125;</span><br><span class="line">        _, err := ws.Upgrade(wcb)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Errorlog(log.NetServerErrorCategory&#123;Summary: fmt.Sprintf(<span class="string">"upgrade[%s] to websocket error: %v"</span>, c.RemoteAddr().String(), err)&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        log.Debugf(log.NetServerDebugCategory&#123;&#125;, <span class="string">"conn[%v] upgrade websocket protocol"</span>, c.RemoteAddr().String())</span><br><span class="line">        cdc.connected = <span class="literal">true</span></span><br><span class="line">        metrics.ConnectedGauge.Inc()</span><br><span class="line">        metrics.TotalConnectedCounter.WithLabelValues(WebsocketApplicationLayerProto.String()).Inc()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg, op, err := wsutil.ReadClientData(c)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := err.(wsutil.ClosedError); !ok &#123;</span><br><span class="line">                log.Errorlog(log.NetServerErrorCategory&#123;Summary: fmt.Sprintf(<span class="string">"[%s] receive ws message error: %v"</span>, c.RemoteAddr().String(), err)&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> gnet.Close</span><br><span class="line">        &#125;</span><br><span class="line">        log.Debugf(log.NetServerDebugCategory&#123;&#125;, <span class="string">"conn[%v] receive [op=%v] [msg=%v]"</span>, c.RemoteAddr().String(), op, <span class="keyword">string</span>(msg))</span><br><span class="line">        <span class="keyword">if</span> op == ws.OpText &#123;</span><br><span class="line">            <span class="keyword">if</span> rs := route.MatchRequestSpec(msg); rs == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> route.GlobalWsRouter.DefaultHandler().ServeWebsocket(<span class="string">"/"</span>, msg, c, op)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> route.GlobalWsRouter.MatchHandler(rs.Path).ServeWebsocket(rs.Path, rs.Params, c, op)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>升级协议的过程中，我们用到了<code>github.com/gobwas/ws</code>这个协议库。</p>
<p>我们在接受到<code>websocket</code>前的时候需要先升级为websocket协议，但是这里遇到了一个问题，还是同理，我们的<code>gnet.Conn</code>的数据已经被我们取出来了，而升级的API显然就是需要提供一个可读可写的IO。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade is like Upgrader&#123;&#125;.Upgrade().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upgrade</span><span class="params">(conn io.ReadWriter)</span> <span class="params">(Handshake, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> DefaultUpgrader.Upgrade(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadWriter is the interface that groups the basic Read and Write methods.</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们又需要实现一个自己的<code>wsConnBridge</code>对象，主要是实现上述的接口，但是这个结构体相对来说就比较简单了，分别保存之前提出来的<code>[]byte</code>的buffer用于读行为，再保存一个<code>gnet.Conn</code>用于写行为即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> wsConnBridge <span class="keyword">struct</span> &#123;</span><br><span class="line">	buff *bytes.Buffer</span><br><span class="line">	c    gnet.Conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsConnBridge)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> w.buff.Read(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wsConnBridge)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> w.c.Write(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>升级完了，我们需要给当前的<code>上下文环境的Context</code>标记为已经升级连接完毕。</p>
<p>然后就是进入到数据的收发环节了。</p>
<p><code>github.com/gobwas/ws</code>提供了<code>api</code>来进行数据的收发，分别有<code>high-level</code>和<code>low-level</code>，这里，我们可优先选择<code>high-level-api</code>，然后读取数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WebsocketHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeWebsocket(path <span class="keyword">string</span>, data []<span class="keyword">byte</span>, w io.Writer, op ws.OpCode) gnet.Action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取到数据之后，又因为我需要和http的route能有一个高度匹配的代码写法，所以在路由匹配上，也是做了一个类似的<code>Match</code>的行为，然后选择到对应的<code>Handler</code>，触发统一的<code>ServeWebsocket()</code>接口（为了和http的<code>ServeHttp()</code>对应）。</p>
<p>到此，从<code>网络层到应用层</code>的<code>端口复用实现多协议</code>原理就到此为止了。</p>
<p>接着就是处理自己的业务逻辑数据了。</p>
<h2 id="业务逻辑概述"><a href="#业务逻辑概述" class="headerlink" title="业务逻辑概述"></a>业务逻辑概述</h2><ol>
<li>记录客服需要监控的数据规则和连接关联</li>
<li>kafka-client从监控规则中匹配合适的数据，推送到对应的fd中 </li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">ListenChatRuleMap.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> Match(key.(<span class="keyword">string</span>), kmsKey) &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c gnet.Conn, wsp *WsSendPayload)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            err := wsutil.WriteServerMessage(c, ws.OpText, wsp.Json())</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Errorf(log.AppErrorCategory&#123;Summary: fmt.Sprintf(<span class="string">"[wsWriteServerMessage failed] [err=%v]"</span>, err)&#125;, <span class="string">"[key=%s],[data=%s]"</span>, key.(<span class="keyword">string</span>), <span class="keyword">string</span>(wsp.Json()))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            atomic.AddInt64(&amp;i, <span class="number">1</span>)</span><br><span class="line">        &#125;(value.(gnet.Conn), wsp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">wg.Wait()</span><br><span class="line">metrics.ChatLogCounterClientHistogram.WithLabelValues(strconv.FormatUint(<span class="keyword">uint64</span>(lrc.Pid), <span class="number">10</span>), strconv.Itoa(wsp.ServerId), strconv.Itoa(wsp.AgentId)).Observe(<span class="keyword">float64</span>(atomic.LoadInt64(&amp;i)))</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>至此，网络层和业务层的所有需求大体已经完毕了。</p>
<h2 id="prometheus-指标"><a href="#prometheus-指标" class="headerlink" title="prometheus 指标"></a>prometheus 指标</h2><p>部分的指标如下，后续可以通过一些指标对服务的稳定和可靠性进行优化升级处理。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># HELP chat_monitor_app_handle_chat_total Counter of handle.</span><br><span class="line"># TYPE chat_monitor_app_handle_chat_total counter</span><br><span class="line">chat_monitor_app_handle_chat_total&#123;agent_id="29",app_id="19",server_id="6558"&#125; 3</span><br><span class="line"># HELP chat_monitor_net_client_recv_counter number of chat log for client</span><br><span class="line"># TYPE chat_monitor_net_client_recv_counter histogram</span><br><span class="line">chat_monitor_net_client_recv_counter_bucket&#123;agent_id="29",pid="1643890670000002",server_id="6558",le="1"&#125; 0</span><br><span class="line">chat_monitor_net_client_recv_counter_bucket&#123;agent_id="29",pid="1643890670000002",server_id="6558",le="2"&#125; 0</span><br><span class="line">chat_monitor_net_client_recv_counter_bucket&#123;agent_id="29",pid="1643890670000002",server_id="6558",le="4"&#125; 2</span><br><span class="line">chat_monitor_net_client_recv_counter_bucket&#123;agent_id="29",pid="1643890670000002",server_id="6558",le="8"&#125; 3</span><br><span class="line">chat_monitor_net_client_recv_counter_bucket&#123;agent_id="29",pid="1643890670000002",server_id="6558",le="16"&#125; 3</span><br><span class="line">chat_monitor_net_client_recv_counter_bucket&#123;agent_id="29",pid="1643890670000002",server_id="6558",le="32"&#125; 3</span><br><span class="line">chat_monitor_net_client_recv_counter_bucket&#123;agent_id="29",pid="1643890670000002",server_id="6558",le="64"&#125; 3</span><br><span class="line">chat_monitor_net_client_recv_counter_bucket&#123;agent_id="29",pid="1643890670000002",server_id="6558",le="+Inf"&#125; 3</span><br><span class="line">chat_monitor_net_client_recv_counter_sum&#123;agent_id="29",pid="1643890670000002",server_id="6558"&#125; 12</span><br><span class="line">chat_monitor_net_client_recv_counter_count&#123;agent_id="29",pid="1643890670000002",server_id="6558"&#125; 3</span><br><span class="line"># HELP chat_monitor_net_current_connected Current Counter Gauge of ws-connected.</span><br><span class="line"># TYPE chat_monitor_net_current_connected gauge</span><br><span class="line">chat_monitor_net_current_connected 4</span><br><span class="line"># HELP chat_monitor_net_total_connected The Total Counter of connected.</span><br><span class="line"># TYPE chat_monitor_net_total_connected counter</span><br><span class="line">chat_monitor_net_total_connected&#123;type="http"&#125; 15</span><br><span class="line">chat_monitor_net_total_connected&#123;type="websocket"&#125; 5</span><br><span class="line"># HELP chat_monitor_server_error_total Counter of error.</span><br><span class="line"># TYPE chat_monitor_server_error_total counter</span><br><span class="line">chat_monitor_server_error_total&#123;type="network_server_error"&#125; 1</span><br><span class="line"># HELP chat_monitor_server_gogc The value of GOGC</span><br><span class="line"># TYPE chat_monitor_server_gogc gauge</span><br><span class="line">chat_monitor_server_gogc 100</span><br><span class="line"># HELP chat_monitor_server_info Indicate the chat_monitor server info, and the value is the start timestamp (s).</span><br><span class="line"># TYPE chat_monitor_server_info gauge</span><br><span class="line">chat_monitor_server_info 1.644568978e+09</span><br><span class="line"># HELP chat_monitor_server_maxprocs The value of GOMAXPROCS.</span><br><span class="line"># TYPE chat_monitor_server_maxprocs gauge</span><br><span class="line">chat_monitor_server_maxprocs 6</span><br></pre></td></tr></table></figure>

<p>到这里，一些基础而核心的逻辑也介绍完了。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Golang/">Golang</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Golang/">Golang</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2025 白菜(whiteCcinn)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>