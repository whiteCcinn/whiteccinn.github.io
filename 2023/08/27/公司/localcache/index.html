<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ssp-adx-localcache优化 | 白菜君の技术库</title>

  
  <meta name="author" content="白菜(whiteCcinn)">
  

  
  <meta name="description" content="知道做不到，等于不知道">
  

  
  <meta name="keywords" content="白菜,文辉,技术博客,whiteCcinn">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="ssp-adx-localcache优化"/>

  <meta property="og:site_name" content="白菜君の技术库"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="白菜君の技术库" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">白菜君の技术库</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/">文章</a></li>
      
        <li><a href="/tags/">标签</a></li>
      
        <li><a href="/categories/">分类</a></li>
      
        <li><a href="/about/">关于我</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>ssp-adx-localcache优化</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/08/27/公司/localcache/" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-27T01:53:00.000Z">
          2023-08-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在处理<code>ssp-adx-rtb</code>的服务的性能优化，做了好多方面的优化，其中一个就是我们的本地的<code>localcache</code>的问题。</p>
<p>经过<code>pprof</code>的性能分析，发现<code>cache2go</code>，在 <code>CPU Flame Graph</code> 中，占比十分严重，基本大于<code>1/3</code>，既然是<code>localcache</code>，那么，我们的目的本意就是为了提速，所以占比那么大，是十分不合理的。</p>
<p>所以需要找到原因，并且解决它。降低cpu使用率，从而提高服务的QPS，减少服务器成本。</p>
<p><img src="/images/%E5%85%AC%E5%8F%B8/cache2go1.jpg" alt="cache2go1"></p>
<a id="more"></a>

<h2 id="cache2go旧版"><a href="#cache2go旧版" class="headerlink" title="cache2go旧版"></a>cache2go旧版</h2><ul>
<li><a href="https://github.com/muesli/cache2go" target="_blank" rel="noopener">cache2go</a></li>
<li><a href="https://github.com/muesli/cache2go" target="_blank" rel="noopener">https://github.com/muesli/cache2go</a></li>
</ul>
<p>项目的描述为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Concurrency-safe Go caching library with expiration capabilities and access counters</span><br></pre></td></tr></table></figure>

<p>并发安全，并且带有效期的和访问计数器的一个类库组件</p>
<p>我们需要用他来解决我们的3大核心问题</p>
<ul>
<li>本地缓存</li>
<li>并发安全</li>
<li>带ttl功能</li>
</ul>
<p>对于开源版本第一版本，我们已经做为处理了。</p>
<p>就是他的淘汰策略，是<code>ttl+lru</code>，当一个缓存在一定时间内被连续访问，或者在一个key，准备过期的时候，如果被访问，那么他的过期时间将继续延长到下一个周期。</p>
<p>这一特点，并不是我们需求，所以我们需要对这一点进行了调整，过期时间，只需要判断为 <code>ttl</code> 过期即可，不需要加上 <code>lru</code> 的方式。</p>
<p>这里就不展开细说。</p>
<h2 id="cache2go新版"><a href="#cache2go新版" class="headerlink" title="cache2go新版"></a>cache2go新版</h2><ul>
<li><a href="https://github.com/whiteCcinn/cache2go" target="_blank" rel="noopener">cache2go-new</a></li>
<li><a href="https://github.com/whiteCcinn/cache2go" target="_blank" rel="noopener">https://github.com/whiteCcinn/cache2go</a></li>
</ul>
<p><img src="/images/%E5%85%AC%E5%8F%B8/localcache.jpg" alt="localcache"></p>
<p><img src="/images/%E5%85%AC%E5%8F%B8/cache2go2.jpg" alt="cache2go2"></p>
<p><img src="/images/%E5%85%AC%E5%8F%B8/cache2go3.jpg" alt="cache2go3"></p>
<p>在这一个版本，基本把整个库都按需重构了。主要是以下几个方面。</p>
<ul>
<li>加入<code>hash分片</code>机制，把key打散到不同的<code>bucket</code>中，让<code>bucket-lock</code>的争抢降低</li>
<li>同一个<code>cache-table</code>，有且仅有一个<code>goroutine</code>，来处理 <code>ttl</code> 数据，并不会因为分片的个数调整带来更多的无效<code>goroutine</code></li>
<li>没有采用渐进式的方式来删除key, 在 <code>add</code>, <code>get</code> 的阶段，尽量保持服务的高效性能，方式由于锁带来的性能衰减</li>
<li>采用<code>双写机制</code>，实现<code>L1</code>和<code>L2</code>的二级包装级别，从而做到 <code>读写分离</code>, 尽可能的避免在必要的场景下由于<code>整个写锁</code>导致<code>读锁阻塞</code>的问题，让后台在处理 <code>ttl</code> 和 <code>重建map</code>的过程中，服务依然高效提供服务</li>
<li>定期重建底层<code>map</code>属性，来释放map申请的内存，让整个服务相对处于一个内存稳定的状态</li>
</ul>
<p><code>需求+机制</code>，就可以在<code>读写较多</code>或者<code>后台需要处理map</code>的情况下，性能依旧保持有一个较好的性能体现。</p>
<p>为了实现这几点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheTable <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.RWMutex</span><br><span class="line"></span><br><span class="line">	hash *fnv64a          <span class="comment">// 用于hash</span></span><br><span class="line">	shardMask <span class="keyword">uint64</span>      <span class="comment">// 用于hash的mask，在做按位与操作的时候，实现求余一样的行为，由于是位运算，效率一般都偏高</span></span><br><span class="line"></span><br><span class="line">	name <span class="keyword">string</span>           <span class="comment">// cache的命名</span></span><br><span class="line"></span><br><span class="line">	L1Shards  shardItems  <span class="comment">// L1的分片组</span></span><br><span class="line">	L2Shards  shardItems  <span class="comment">// L2的分片组</span></span><br><span class="line"></span><br><span class="line">	cleanupInterval time.Duration  <span class="comment">// 定时处理ttl的数据</span></span><br><span class="line"></span><br><span class="line">	l1BlockChan []*CacheItem <span class="comment">// 用于在L1分片组被后台处理过程中，暂时把数据缓存起来</span></span><br><span class="line">	l2BlockChan []*CacheItem <span class="comment">// 用于在L2分片组被后台处理过程中，暂时把数据缓存起来</span></span><br><span class="line"></span><br><span class="line">	l1Mask <span class="keyword">int32</span> <span class="comment">// L1原子计数器，用来代替lock，防止lock的堵塞现象，导致服务被影响</span></span><br><span class="line">	l2Mask <span class="keyword">int32</span> <span class="comment">// L2原子计数器，用来代替lock，防止lock的堵塞现象，导致服务被影响</span></span><br><span class="line"></span><br><span class="line">	switchMask <span class="keyword">uint8</span> <span class="comment">// 记录当前 cache-table是否在处理L1,L2分片组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>这是一个写入过程，实现起来也不算太复杂</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span> &#123;</span><br><span class="line">	item := NewCacheItem(key, lifeSpan, data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前表是否在处理L1</span></span><br><span class="line">	<span class="keyword">if</span> table.switchMask != <span class="number">1</span>&lt;&lt;<span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 记录L1正在处理写入行为，+1操作</span></span><br><span class="line">		atomic.AddInt32(&amp;table.l1Mask, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 结束的时候L1写入的时候，-1操作</span></span><br><span class="line">		<span class="keyword">defer</span> atomic.AddInt32(&amp;table.l1Mask, <span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// L1内部分片片级写锁开发</span></span><br><span class="line">		table.L1Shards[item.hashedKey&amp;table.shardMask].lock.Lock()</span><br><span class="line">        <span class="comment">// L1内部分片写入item</span></span><br><span class="line">		table.L1Shards[item.hashedKey&amp;table.shardMask].m[item.key] = item</span><br><span class="line">        <span class="comment">// L1内部分片片级写锁结束</span></span><br><span class="line">		table.L1Shards[item.hashedKey&amp;table.shardMask].lock.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前后台在处理L1的话，那么先缓存起来</span></span><br><span class="line">		table.l1BlockChan = <span class="built_in">append</span>(table.l1BlockChan, item)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前表是否在处理L2</span></span><br><span class="line">	<span class="keyword">if</span> table.switchMask != <span class="number">1</span>&lt;&lt;<span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">// 记录L2正在处理写入行为，+1操作</span></span><br><span class="line">		atomic.AddInt32(&amp;table.l2Mask, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 结束的时候L2写入的时候，-1操作</span></span><br><span class="line">		<span class="keyword">defer</span> atomic.AddInt32(&amp;table.l2Mask, <span class="number">-1</span>)</span><br><span class="line">        <span class="comment">// L2内部分片片级写锁开发</span></span><br><span class="line">		table.L2Shards[item.hashedKey&amp;table.shardMask].lock.Lock()</span><br><span class="line">        <span class="comment">// L2内部分片写入item</span></span><br><span class="line">		table.L2Shards[item.hashedKey&amp;table.shardMask].m[item.key] = item</span><br><span class="line">        <span class="comment">// L2内部分片片级写锁结束</span></span><br><span class="line">		table.L2Shards[item.hashedKey&amp;table.shardMask].lock.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前后台在处理L2的话，那么先缓存起来</span></span><br><span class="line">		table.l2BlockChan = <span class="built_in">append</span>(table.l2BlockChan, item)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过双写的方式，实现<code>L1</code>和<code>L2</code>的同时写入,以此达到空间换时间的做法。</p>
<p>其中 <code>(&amp; 2^(n-1))</code> 做到 <code>(%m)</code>的效果，并且由于是位运算，所以按理说效率会更高</p>
<h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><blockquote>
<p>Value 和 就是Get方法，获取key的item</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">	keyBytes, _ := json.Marshal(key)</span><br><span class="line">    <span class="comment">// 哈希的key</span></span><br><span class="line">	hashedKey := table.hash.Sum64(<span class="keyword">string</span>(keyBytes))</span><br><span class="line">	<span class="keyword">var</span> sm *shardItem</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> table.switchMask == <span class="number">1</span>&gt;&gt;<span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// 先查l1</span></span><br><span class="line">		sm = table.L1Shards[hashedKey&amp;table.shardMask]</span><br><span class="line">		sm.lock.RLock()</span><br><span class="line">		r, ok := sm.m[key]</span><br><span class="line">		sm.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="comment">// 正常返回结果</span></span><br><span class="line">			<span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 再查l2</span></span><br><span class="line">		sm = table.L2Shards[hashedKey&amp;table.shardMask]</span><br><span class="line">		sm.lock.RLock()</span><br><span class="line">		r, ok = sm.m[key]</span><br><span class="line">		sm.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="comment">// 正常返回结果</span></span><br><span class="line">			<span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找不到key</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> table.switchMask == <span class="number">1</span>&lt;&lt;<span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// 正在处理l1，需要从l2读</span></span><br><span class="line">		sm = table.L2Shards[hashedKey&amp;table.shardMask]</span><br><span class="line">		sm.lock.RLock()</span><br><span class="line">		r, ok := sm.m[key]</span><br><span class="line">		sm.lock.RUnlock()</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="comment">// 正常返回结果</span></span><br><span class="line">			<span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找不到key</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 正在处理l2，需要从l1读</span></span><br><span class="line">		sm = table.L1Shards[hashedKey&amp;table.shardMask]</span><br><span class="line">		sm.lock.RLock()</span><br><span class="line">		r, ok := sm.m[key]</span><br><span class="line">		sm.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="comment">// 正常返回结果</span></span><br><span class="line">			<span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找不到key</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到这里，如果后台没有在操作<code>L1</code>, <code>L2</code> 的话，那么先从<code>L1</code>拿数据，然后再从<code>L2</code>拿数据</li>
<li>如果后台在<code>操作L1</code>, 那么只能从 <code>L2</code> 读取</li>
<li>如果后台在<code>操作L2</code>, 那么只能从 <code>L1</code> 读取</li>
</ul>
<p>所以通过<code>L1</code>和<code>L2</code>，我们实现了一个读写分离的策略，并且在最大的程度上减少<code>分片锁</code>的读写锁冲突，从而提高服务的效率</p>
<h2 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时清理过期缓存</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(t *CacheTable, ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定时监测ttl数据</span></span><br><span class="line">    ticker := time.NewTicker(cleanInterval)</span><br><span class="line">    <span class="comment">// 定期重建map，以此来释放map申请的空间</span></span><br><span class="line">    reBuildTicker := time.NewTicker(<span class="number">30</span> * time.Minute)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            ticker.Stop()</span><br><span class="line">            reBuildTicker.Stop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            <span class="comment">// 表锁</span></span><br><span class="line">            t.Lock()</span><br><span class="line">            <span class="comment">// 扫描需要删除的key</span></span><br><span class="line">            <span class="keyword">var</span> deleteList []*CacheItem</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先处理l1，再处理l2</span></span><br><span class="line">            t.switchMask = <span class="number">1</span> &lt;&lt; <span class="number">1</span></span><br><span class="line">            now := time.Now()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理l1</span></span><br><span class="line">            <span class="comment">// 不允许l1读写入，读写通过l2</span></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> atomic.LoadInt32(&amp;t.l1Mask) == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 当L1已经操作完Add操作的时候继续往下走</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> i, sad := <span class="keyword">range</span> t.L1Shards &#123;</span><br><span class="line">                <span class="comment">// 分片片级别读锁</span></span><br><span class="line">                sad.lock.RLock()</span><br><span class="line">                <span class="keyword">for</span> _, r := <span class="keyword">range</span> sad.m &#123;</span><br><span class="line">                    <span class="comment">// ttl数据校验处理</span></span><br><span class="line">                    <span class="keyword">if</span> now.Sub(r.createdOn).Seconds() &gt; r.lifeSpan.Seconds() &#123;</span><br><span class="line">                        deleteList = <span class="built_in">append</span>(deleteList, r)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sad.lock.RUnlock()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开始删除</span></span><br><span class="line">            <span class="keyword">for</span> _, item := <span class="keyword">range</span> deleteList &#123;</span><br><span class="line">                <span class="comment">// 分片片级别写锁，防止在 Value操作的时候，并行读写异常</span></span><br><span class="line">                t.L1Shards[item.hashedKey&amp;t.shardMask].lock.Lock()</span><br><span class="line">                <span class="built_in">delete</span>(t.L1Shards[item.hashedKey&amp;t.shardMask].m, item.key)</span><br><span class="line">                t.L1Shards[item.hashedKey&amp;t.shardMask].lock.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置deleteList</span></span><br><span class="line">            deleteList = <span class="built_in">make</span>([]*CacheItem, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理完l1,处理l2</span></span><br><span class="line">            t.switchMask = <span class="number">1</span> &lt;&lt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 堵塞的item加回来到l1</span></span><br><span class="line">            l1Length := <span class="built_in">len</span>(t.l1BlockChan)</span><br><span class="line">            <span class="keyword">for</span> _, item := <span class="keyword">range</span> t.l1BlockChan &#123;</span><br><span class="line">                <span class="keyword">if</span> item != <span class="literal">nil</span> &#123;</span><br><span class="line">                    t.L1Shards[item.hashedKey&amp;t.shardMask].lock.Lock()</span><br><span class="line">                    t.L1Shards[item.hashedKey&amp;t.shardMask].m[item.key] = item</span><br><span class="line">                    t.L1Shards[item.hashedKey&amp;t.shardMask].lock.Unlock()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置l1BlockChan, 预先申请大小为原来到一半</span></span><br><span class="line">            t.l1BlockChan = <span class="built_in">make</span>([]*CacheItem, <span class="number">0</span>, l1Length/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不允许l2读写入，读写通过l1</span></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> atomic.LoadInt32(&amp;t.l2Mask) == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i, sad := <span class="keyword">range</span> t.L2Shards &#123;</span><br><span class="line">                sad.lock.RLock()</span><br><span class="line">                <span class="keyword">for</span> _, r := <span class="keyword">range</span> sad.m &#123;</span><br><span class="line">                    <span class="keyword">if</span> now.Sub(r.createdOn).Seconds() &gt; r.lifeSpan.Seconds() &#123;</span><br><span class="line">                        deleteList = <span class="built_in">append</span>(deleteList, r)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sad.lock.RUnlock()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始删除</span></span><br><span class="line">            <span class="keyword">for</span> _, item := <span class="keyword">range</span> deleteList &#123;</span><br><span class="line">                t.L2Shards[item.hashedKey&amp;t.shardMask].lock.Lock()</span><br><span class="line">                <span class="built_in">delete</span>(t.L2Shards[item.hashedKey&amp;t.shardMask].m, item.key)</span><br><span class="line">                t.L2Shards[item.hashedKey&amp;t.shardMask].lock.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 恢复正常</span></span><br><span class="line">            t.switchMask = <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _, item := <span class="keyword">range</span> t.l2BlockChan &#123;</span><br><span class="line">                <span class="comment">//fmt.Println(t.name, t.L1Shards[item.hashedKey&amp;t.shardMask])</span></span><br><span class="line">                <span class="keyword">if</span> item != <span class="literal">nil</span> &#123;</span><br><span class="line">                    t.L2Shards[item.hashedKey&amp;t.shardMask].lock.Lock()</span><br><span class="line">                    t.L2Shards[item.hashedKey&amp;t.shardMask].m[item.key] = item</span><br><span class="line">                    t.L2Shards[item.hashedKey&amp;t.shardMask].lock.Unlock()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置l2BlockChan</span></span><br><span class="line">            t.l2BlockChan = <span class="built_in">make</span>([]*CacheItem, <span class="number">0</span>, l2Length/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            t.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> &lt;-reBuildTicker.C:</span><br><span class="line">            t.Lock()</span><br><span class="line">            <span class="comment">// 为了释放map内存</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先处理l1，再处理l2</span></span><br><span class="line">            t.switchMask = <span class="number">1</span> &lt;&lt; <span class="number">1</span></span><br><span class="line">            now := time.Now()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理l1</span></span><br><span class="line">            <span class="comment">// 不允许l1读写入，读写通过l2</span></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> atomic.LoadInt32(&amp;t.l1Mask) == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _, sad := <span class="keyword">range</span> t.L1Shards &#123;</span><br><span class="line">                sad.lock.Lock()</span><br><span class="line">                nm := <span class="built_in">make</span>(shard, <span class="built_in">len</span>(sad.m))</span><br><span class="line">                <span class="keyword">for</span> key, r := <span class="keyword">range</span> sad.m &#123;</span><br><span class="line">                    <span class="keyword">if</span> now.Sub(r.createdOn).Seconds() &lt; r.lifeSpan.Seconds() &#123;</span><br><span class="line">                        nm[key] = r</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sad.m = <span class="literal">nil</span></span><br><span class="line">                sad.m = nm</span><br><span class="line">                sad.lock.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先处理l1，再处理l2</span></span><br><span class="line">            t.switchMask = <span class="number">1</span> &lt;&lt; <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> atomic.LoadInt32(&amp;t.l2Mask) == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _, sad := <span class="keyword">range</span> t.L2Shards &#123;</span><br><span class="line">                sad.lock.Lock()</span><br><span class="line">                nm := <span class="built_in">make</span>(shard, <span class="built_in">len</span>(sad.m))</span><br><span class="line">                <span class="keyword">for</span> key, r := <span class="keyword">range</span> sad.m &#123;</span><br><span class="line">                    <span class="keyword">if</span> now.Sub(r.createdOn).Seconds() &lt; r.lifeSpan.Seconds() &#123;</span><br><span class="line">                        nm[key] = r</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sad.m = <span class="literal">nil</span></span><br><span class="line">                sad.m = nm</span><br><span class="line">                sad.lock.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 恢复正常</span></span><br><span class="line">            t.switchMask = <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            runtime.GC()</span><br><span class="line">            debug.FreeOSMemory()</span><br><span class="line">            t.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(t, ctx)</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/组件优化/">组件优化</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/cache/">cache</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2025 白菜(whiteCcinn)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>