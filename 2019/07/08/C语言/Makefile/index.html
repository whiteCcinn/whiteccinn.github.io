<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>【C语言】- Makefile | 白菜君の技术库</title>

  
  <meta name="author" content="白菜(whiteCcinn)">
  

  
  <meta name="description" content="知道做不到，等于不知道">
  

  
  <meta name="keywords" content="白菜,文辉,技术博客,whiteCcinn">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="【C语言】- Makefile"/>

  <meta property="og:site_name" content="白菜君の技术库"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="白菜君の技术库" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">白菜君の技术库</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/">文章</a></li>
      
        <li><a href="/tags/">标签</a></li>
      
        <li><a href="/categories/">分类</a></li>
      
        <li><a href="/about/">关于我</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>【C语言】- Makefile</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/08/C语言/Makefile/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-08T02:11:09.000Z">
          2019-07-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是 makefile？或许很多 Winodws 的程序员都不知道这个东西，因为那些 Windows 的 IDE 都为你做了这个工作，但我觉得要作一个好的和 professional 的程序员，makefile 还是要懂。这就好像现在有这么多的 HTML 的编辑器，但如果你想成为一个专业人士，你还是要了解 HTML 的标识的含义。特别在 Unix 下的软件编译，你就不能不自己写 makefile 了，<code>会不会写 makefile，从一个侧面说明了一个人是否具备完成大型工程的能力</code>。因为，makefile 关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。<code>makefile 带来的好处就是——“自动化编译”</code>，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 makefile 中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如：Delphi 的 make，Visual C++的 nmake，Linux 下 GNU 的 make。可见，makefile 都成为了一种在工程方面的编译方法。</p>
<blockquote>
<p>其实在我眼中，感觉 makefile 文件其实就是等于一个 shell 文件，用于处理“自动化”的内容，只不过它是由 C 语言程序本身解析的。</p>
</blockquote>
<a id="more"></a>

<h2 id="Makefile-书写命令"><a href="#Makefile-书写命令" class="headerlink" title="Makefile 书写命令"></a>Makefile 书写命令</h2><h3 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h3><p>通常，make 会把其要执行的命令行在命令执行前输出到屏幕上。当我们用<code>“@”字符在命令行前</code>，那么，这个命令将不被 make 显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@echo 正在编译 XXX 模块......</span><br></pre></td></tr></table></figure>

<p>当 make 执行时，会输出“正在编译 XXX 模块……”字串，但不会输出命令，如果没有“@”，那么，make 将输出：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 正在编译 XXX 模块......</span><br><span class="line"></span><br><span class="line">正在编译 XXX 模块......</span><br></pre></td></tr></table></figure>

<p>如果 make 执行时，带入 make 参数<code>“-n”或“--just-print”</code>，那么其<code>只是显示命令，但不会执行命令</code>，这个功能很有利于我们<code>调试我们的 Makefile</code>，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>
<p>而 make 参数<code>“-s”或“--slient”</code>则是<code>全面禁止命令的显示</code>。</p>
<blockquote>
<p>类似于 bash -x 一样</p>
</blockquote>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make 会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是 cd 命令，你希望第二条命令得在 cd 之后的基础上运行，那么你就<code>不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔</code>。</p>
<p>错误例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">  cd /home/ccinn</span><br><span class="line">  pwd</span><br></pre></td></tr></table></figure>

<p>正确例子:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">  cd /home/ccinn; pwd</span><br></pre></td></tr></table></figure>

<h3 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h3><p>每当命令运行完后，make 会检测每个命令的返回码，如果命令返回成功，那么 make 会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么 make 就会终止执行当前规则，这将有可能终止所有规则的执行。</p>
<p>有些时候，命令的出错并不表示就是错误的。例如 mkdir 命令，我们一定需要建立一个目录，如果目录不存在，那么 mkdir 就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用 mkdir 的意思就是一定要有这样的一个目录，于是我们就不希望 mkdir 出错而终止规则的运行。</p>
<p>为了做到这一点，<code>忽略命令的出错</code>，我们可以在 Makefile 的命令行前<code>加一个减号“-”（在 Tab 键之后）</code>，标记为<code>不管命令出不出错都认为是成功的</code>。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">build:</span></span><br><span class="line">  -mdkir /home/ccinn</span><br></pre></td></tr></table></figure>

<p>还有一个全局的办法是，给 make 加上<code>“-i”或是“--ignore-errors”参数</code>，那么，Makefile 中所有命令都会忽略错误。而如果一个规则是以<code>“.IGNORE”作为目标</code>的，那么这个规则中的所有命令将会忽略错误。这些是<code>不同级别的防止命令出错的方法</code>，你可以根据你的不同喜欢设置。</p>
<p>还有一个要提一下的 make 的参数的是<code>“-k”或是“--keep-going”</code>，这个参数的意思是，<code>如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则</code>。</p>
<h3 id="嵌套执行-make"><a href="#嵌套执行-make" class="headerlink" title="嵌套执行 make"></a>嵌套执行 make</h3><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的 Makefile，这有利于让我们的 Makefile 变得更加地简洁，而不至于把所有的东西全部写在一个 Makefile 中，这样会很难维护我们的 Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫 subdir，这个目录下有个 Makefile 文件，来指明了这个目录下文件的编译规则。那么我们<code>总控的 Makefile</code> 可以这样书写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">  cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure>

<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">  <span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>

<p>定义$(MAKE)宏变量的意思是，也许我们的 make 需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行 make 命令。</p>
<p>我们把这个 Makefile 叫做“总控 Makefile”，<code>总控 Makefile 的变量可以传递到下级的 Makefile 中（如果你显示的声明），但是不会覆盖下层的 Makefile 中所定义的变量，除非指定了“-e”参数。</code></p>
<p>如果你要传递变量到下级 Makefile 中，那么你可以使用这样的声明：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span>&lt;variable ...&gt;</span><br></pre></td></tr></table></figure>

<p>如果你不想让某些变量传递到下级 Makefile 中，那么你可以这样声明：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unexport</span>&lt;variable ...&gt;</span><br></pre></td></tr></table></figure>

<h4 id="示例一："><a href="#示例一：" class="headerlink" title="示例一："></a>示例一：</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> variable = value</span><br></pre></td></tr></table></figure>

<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure>

<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> variable := value</span><br></pre></td></tr></table></figure>

<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable := value</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure>

<h4 id="示例二："><a href="#示例二：" class="headerlink" title="示例二："></a>示例二：</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> variable += value</span><br></pre></td></tr></table></figure>

<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable += value</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure>

<p><code>如果你要传递所有的变量，那么，只要一个export就行了</code>。后面什么也不用跟，表示传递所有的变量。</p>
<p>需要注意的是，有两个变量，一个是 <code>SHELL</code>，一个是<code>MAKEFLAGS</code>，这两个变量不管你是否 export，其总是要传递到下层 Makefile 中，<code>特别是 MAKEFILES 变量，其中包含了 make 的参数信息</code>，如果我们执行“总控 Makefile”时有 make 参数或是在上层 Makefile 中定义了这个变量，那么 MAKEFILES 变量将会是这些参数，并会传递到下层 Makefile 中，这是一个系统级的环境变量。</p>
<p>但是 make 命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关 Makefile 参数的细节将在后面说明），<code>如果你不想往下层传递参数</code>，那么，你可以这样来：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">  cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> MAKEFLAGS=</span><br></pre></td></tr></table></figure>

<p>如果你定义了环境变量 MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</p>
<p>还有一个在“嵌套执行”中比较有用的参数，<code>“-w”或是“--print-directory”会在 make 的过程中输出一些信息</code>，让你看到目前的工作目录。比如，如果我们的下级 make 目录是“/home/ccinn/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">make: Entering directory `/home/ccinn/gnu/make'.</span></span><br></pre></td></tr></table></figure>

<p>而在完成下层 make 后离开目录时，我们会看到：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">make: Leaving directory `/home/ccinn/gnu/make'</span></span><br></pre></td></tr></table></figure>

<p>当你使用“-C”参数来指定 make 下层 Makefile 时，“-w”会被自动打开的。</p>
<blockquote>
<p>如果参数中有“-s”（“–slient”）或是“–no-print-directory”，那么，“-w”总是失效的。</p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/C语言/">C语言</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/C语言/">C语言</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 白菜(whiteCcinn)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>