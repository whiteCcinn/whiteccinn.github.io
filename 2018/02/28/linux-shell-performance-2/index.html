<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>【Linux命令】- 性能优化 | 白菜君の技术库</title>

  
  <meta name="author" content="白菜(whiteCcinn)">
  

  
  <meta name="description" content="知道做不到，等于不知道">
  

  
  <meta name="keywords" content="白菜,文辉,技术博客,whiteCcinn">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="【Linux命令】- 性能优化"/>

  <meta property="og:site_name" content="白菜君の技术库"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="白菜君の技术库" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">白菜君の技术库</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/">文章</a></li>
      
        <li><a href="/tags/">标签</a></li>
      
        <li><a href="/categories/">分类</a></li>
      
        <li><a href="/about/">关于我</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>【Linux命令】- 性能优化</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/28/linux-shell-performance-2/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-28T07:10:06.000Z">
          2018-02-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>contents:: 目录</p>
<p>性能优化的核心是找出系统的瓶颈点，问题找到了，优化的工作也就完成了大半；<br>这里介绍的性能优化主要从两个层面来介绍：系统层面和程序层面；</p>
<h2 id="分析系统瓶颈"><a href="#分析系统瓶颈" class="headerlink" title="分析系统瓶颈"></a>分析系统瓶颈</h2><p>系统响应变慢，首先得定位大致的问题出在哪里，是 IO 瓶颈、CPU 瓶颈、内存瓶颈还是程序导致的系统问题；</p>
<p>使用 top 工具能够比较全面的查看我们关注的点::</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$top</span><br><span class="line">top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00</span><br><span class="line">Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st</span><br><span class="line">Mem:    377672k total,   322332k used,    55340k free,    32592k buffers</span><br><span class="line">Swap:   397308k total,    67192k used,   330116k free,    71900k cached</span><br><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init</span><br><span class="line">2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd</span><br><span class="line">3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd&#x2F;0</span><br><span class="line">4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration&#x2F;</span><br></pre></td></tr></table></figure>

<p>进入交互模式后: - 输入 M，进程列表按内存使用大小降序排序，便于我们观察最大内存使用者使用有问题（检测内存泄漏问题）; - 输入 P，进程列表按 CPU 使用大小降序排序，便于我们观察最耗 CPU 资源的使用者是否有问题；</p>
<p>top 第三行显示当前系统的，其中有两个值很关键: - %id：空闲 CPU 时间百分比，如果这个值过低，表明系统 CPU 存在瓶颈； - %wa：等待 I/O 的 CPU 时间百分比，如果这个值过高，表明 IO 存在瓶颈；</p>
<h2 id="分析内存瓶颈"><a href="#分析内存瓶颈" class="headerlink" title="分析内存瓶颈"></a>分析内存瓶颈</h2><p>查看内存是否存在瓶颈，使用 top 指令看比较麻烦，而 free 命令更为直观::</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;home&#x2F;weber#]free</span><br><span class="line">              total       used       free     shared    buffers     cached</span><br><span class="line">Mem:        501820     452028      49792      37064       5056     136732</span><br><span class="line">-&#x2F;+ buffers&#x2F;cache:     310240     191580</span><br><span class="line">Swap:            0          0          0</span><br><span class="line">[&#x2F;home&#x2F;weber#]top</span><br><span class="line">top - 17:52:17 up 42 days,  7:10,  1 user,  load average: 0.02, 0.02, 0.05</span><br><span class="line">Tasks:  80 total,   1 running,  79 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem:    501820 total,   452548 used,    49272 free,     5144 buffers</span><br><span class="line">KiB Swap:        0 total,        0 used,        0 free.   136988 cached Mem</span><br></pre></td></tr></table></figure>

<p>top 工具显示了 free 工具的第一行所有信息，但真实可用的内存，还需要自己计算才知道;<br>系统实际可用的内存为 free 工具输出第二行的 free+buffer+cached；也就是第三行的 free 值 191580；关于 free 命令各个值的详情解读，请参考这篇文章 :ref:<code>free</code> ;</p>
<p>如果是因为缺少内存，系统响应变慢很明显，因为这使得系统不停的做换入换出的工作;</p>
<p>进一步的监视内存使用情况，可使用 vmstat 工具，实时动态监视操作系统的内存和虚拟内存的动态变化。<br>参考： :ref:<code>vmstat</code> ;</p>
<h2 id="分析-IO-瓶颈"><a href="#分析-IO-瓶颈" class="headerlink" title="分析 IO 瓶颈"></a>分析 IO 瓶颈</h2><p>如果 IO 存在性能瓶颈，top 工具中的%wa 会偏高；</p>
<p>进一步分析使用 iostat 工具::</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;root$iostat -d -x -k 1 1</span><br><span class="line">Linux 2.6.32-279.el6.x86_64 (colin)   07&#x2F;16&#x2F;2014      _x86_64_        (4 CPU)</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rkB&#x2F;s    wkB&#x2F;s avgrq-sz avgqu-sz   await  svctm  %util</span><br><span class="line">sda               0.02     7.25    0.04    1.90     0.74    35.47    37.15     0.04   19.13   5.58   1.09</span><br><span class="line">dm-0              0.00     0.00    0.04    3.05     0.28    12.18     8.07     0.65  209.01   1.11   0.34</span><br><span class="line">dm-1              0.00     0.00    0.02    5.82     0.46    23.26     8.13     0.43   74.33   1.30   0.76</span><br><span class="line">dm-2              0.00     0.00    0.00    0.01     0.00     0.02     8.00     0.00    5.41   3.28   0.00</span><br></pre></td></tr></table></figure>

<ul>
<li>如果%iowait 的值过高，表示硬盘存在 I/O 瓶颈。</li>
<li>如果 %util 接近 100%，说明产生的 I/O 请求太多，I/O 系统已经满负荷，该磁盘可能存在瓶颈。</li>
<li>如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；</li>
<li>如果 await 远大于 svctm，说明 I/O 队列太长，io 响应太慢，则需要进行必要优化。</li>
<li>如果 avgqu-sz 比较大，也表示有大量 io 在等待。</li>
</ul>
<p>更多参数说明请参考 :ref:<code>iostat</code> ;</p>
<h2 id="分析进程调用"><a href="#分析进程调用" class="headerlink" title="分析进程调用"></a>分析进程调用</h2><p>通过 top 等工具发现系统性能问题是由某个进程导致的之后，接下来我们就需要分析这个进程；继续<br>查询问题在哪；</p>
<p>这里我们有两个好用的工具：<br>pstack 和 pstrace</p>
<p>pstack 用来跟踪进程栈，这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于 work 状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次 pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方；</p>
<p>示例：查看 bash 程序进程栈::</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;opt&#x2F;app&#x2F;tdev1$ps -fe| grep bash</span><br><span class="line">tdev1   7013  7012  0 19:42 pts&#x2F;1    00:00:00 -bash</span><br><span class="line">tdev1  11402 11401  0 20:31 pts&#x2F;2    00:00:00 -bash</span><br><span class="line">tdev1  11474 11402  0 20:32 pts&#x2F;2    00:00:00 grep bash</span><br><span class="line">&#x2F;opt&#x2F;app&#x2F;tdev1$pstack 7013</span><br><span class="line">#0  0x00000039958c5620 in __read_nocancel () from &#x2F;lib64&#x2F;libc.so.6</span><br><span class="line">#1  0x000000000047dafe in rl_getc ()</span><br><span class="line">#2  0x000000000047def6 in rl_read_key ()</span><br><span class="line">#3  0x000000000046d0f5 in readline_internal_char ()</span><br><span class="line">#4  0x000000000046d4e5 in readline ()</span><br><span class="line">#5  0x00000000004213cf in ?? ()</span><br><span class="line">#6  0x000000000041d685 in ?? ()</span><br><span class="line">#7  0x000000000041e89e in ?? ()</span><br><span class="line">#8  0x00000000004218dc in yyparse ()</span><br><span class="line">#9  0x000000000041b507 in parse_command ()</span><br><span class="line">#10 0x000000000041b5c6 in read_command ()</span><br><span class="line">#11 0x000000000041b74e in reader_loop ()</span><br><span class="line">#12 0x000000000041b2aa in main ()</span><br></pre></td></tr></table></figure>

<p>而 strace 用来跟踪进程中的系统调用；这个工具能够动态的跟踪进程执行时的系统调用和所接收的信号。是一个非常有效的检测、指导和调试工具。系统管理员可以通过该命令容易地解决程序问题。</p>
<p>参考： :ref:<code>strace</code> ;</p>
<h2 id="优化程序代码"><a href="#优化程序代码" class="headerlink" title="优化程序代码"></a>优化程序代码</h2><p>优化自己开发的程序，建议采用以下准则::</p>
<ol>
<li>二八法则：在任何一组东西中，最重要的只占其中一小部分，约 20%，其余 80%的尽管是多数，却是次要的；在优化实践中，我们将精力集中在优化那 20%最耗时的代码上，整体性能将有显著的提升；这个很好理解。函数 A 虽然代码量大，但在一次正常执行流程中，只调用了一次。而另一个函数 B 代码量比 A 小很多，但被调用了 1000 次。显然，我们更应关注 B 的优化。</li>
<li>编完代码，再优化；编码的时候总是考虑最佳性能未必总是好的；在强调最佳性能的编码方式的同时，可能就损失了代码的可读性和开发效率；</li>
</ol>
<p>gprof 使用步骤</p>
<ol>
<li>用 gcc、g++、xlC 编译程序时，使用-pg 参数，如：g++ -pg -o test.exe test.cpp 编译器会自动在目标代码中插入用于性能测试的代码片断，这些代码在程序运行时采集并记录函数的调用关系和调用次数，并记录函数自身执行时间和被调用函数的执行时间。</li>
<li>执行编译后的可执行程序，如：./test.exe。该步骤运行程序的时间会稍慢于正常编译的可执行程序的运行时间。程序运行结束后，会在程序所在路径下生成一个缺省文件名为 gmon.out 的文件，这个文件就是记录程序运行的性能、调用关系、调用次数等信息的数据文件。</li>
<li>使用 gprof 命令来分析记录程序运行信息的 gmon.out 文件，如：gprof test.exe gmon.out 则可以在显示器上看到函数调用相关的统计、分析信息。上述信息也可以采用 gprof test.exe gmon.out&gt; gprofresult.txt 重定向到文本文件以便于后续分析。</li>
</ol>
<p>关于 gprof 的使用案例，请参考 [f1]_ ;</p>
<h2 id="其它工具"><a href="#其它工具" class="headerlink" title="其它工具"></a>其它工具</h2><p>调试内存泄漏的工具 valgrind，感兴趣的朋友可以 google 了解；</p>
<p>OProfile: Linux 平台上的一个功能强大的性能分析工具,使用参考 [f2]_ ;</p>
<p>除了上面介绍的工具，还有一些比较全面的性能分析工具，比如 sar（Linux 系统上默认不安装，需要手动安装下）；<br>将 sar 的常驻监控工具打开后，能够收集比较全面的性能分析数据；</p>
<p>关于 sar 的使用，参考 :ref:<code>sar</code> ;</p>
<p>.. [f1] C++的性能优化实践 <a href="http://www.cnblogs.com/me115/archive/2013/06/05/3117967.html" target="_blank" rel="noopener">http://www.cnblogs.com/me115/archive/2013/06/05/3117967.html</a><br>.. [f2] 用 OProfile 彻底了解性能 <a href="http://www.ibm.com/developerworks/cn/linux/l-oprof/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/l-oprof/</a><br>.. [f3] Linux 上的 free 命令详解 <a href="http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html" target="_blank" rel="noopener">http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Linux/">Linux</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Linux/">Linux</a><a href="/tags/Shell/">Shell</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 白菜(whiteCcinn)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>