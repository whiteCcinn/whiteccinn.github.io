<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>【数据库开发】msource | 白菜君の技术库</title>

  
  <meta name="author" content="白菜(whiteCcinn)">
  

  
  <meta name="description" content="知道做不到，等于不知道">
  

  
  <meta name="keywords" content="白菜,文辉,技术博客,whiteCcinn">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="【数据库开发】msource"/>

  <meta property="og:site_name" content="白菜君の技术库"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="白菜君の技术库" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">白菜君の技术库</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/">文章</a></li>
      
        <li><a href="/tags/">标签</a></li>
      
        <li><a href="/categories/">分类</a></li>
      
        <li><a href="/about/">关于我</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>【数据库开发】msource</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/03/27/数据库开发知识/msource/" rel="bookmark">
        <time class="entry-date published" datetime="2021-03-26T17:16:43.000Z">
          2021-03-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>CAP</code>原则又称CAP定理，指的是在一个分布式系统中，<code>一致性（Consistency）</code>、<code>可用性（Availability）</code>、<code>分区容错性（Partition tolerance）</code>。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p>
<p><code>msource</code> 是我们的一个 <code>数据源组件</code>，我们所有的大数据ETL服务都构建在此之上，所以我们msource可以说是所有业务系统的核心。他维护着一个稳定，可靠，高性能的数据传输机制。让我们 <code>业务层</code> 中可以做各种操作，同步，异步等等。</p>
<p>msource 的角色我大体分为了2种：</p>
<ul>
<li>spout （数据推送组件)</li>
<li>db （数据存储组件）</li>
</ul>
<a id="more"></a>

<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/spout_db_relation.png" alt=" spout和db的关系 "></p>
<p>在这个图中，我们可以看到，db可以独立出来应用，他不依赖于spout。spout默认的传输机制是我们golang中的channel模式，但是它可以选择使用db模式。</p>
<h1 id="MSOURCE-DB"><a href="#MSOURCE-DB" class="headerlink" title="MSOURCE_DB"></a>MSOURCE_DB</h1><h2 id="RockesDB的基础知识"><a href="#RockesDB的基础知识" class="headerlink" title="RockesDB的基础知识"></a>RockesDB的基础知识</h2><p>rocksdb 我们知道他是支持WAL（Write Ahead Log）的，一般的log文件中通常包括 <code>redo log</code> 和 <code>undo log</code>。其实这不仅仅是rocksdb独有的，这是一种可靠性的保证，像mysql一样有这种机制，也是分为<code>redo log</code>, <code>undo log</code>, <code>binlog</code>，区别就在于 <code>binlog</code> 属于逻辑日志，<code>redo log</code>和<code>undo log</code>属于物理日志。</p>
<p>rocksdb是facebook开发的一个<code>kv存储引擎</code>。他的机构模式是基于<code>LSM</code>的。基于LSM的架构都需要经过一个叫 <code>Compaction</code>  过程，通常Compaction涉及到三个放大因子。</p>
<p>Compaction需要在三者之间做取舍。</p>
<ul>
<li>写放大 （Write Amplification）</li>
<li>读放大（Read Amplification）</li>
<li>空间放大 （Space Amplification）</li>
</ul>
<p>后台的 compaction 来减少读放大（减少 SST 文件数量）和空间放大（清理过期数据），但也因此带来了写放大（Write Amplification）的问题。</p>
<h3 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h3><h4 id="写放大"><a href="#写放大" class="headerlink" title="写放大"></a>写放大</h4><p>假设每秒写入10MB的数据，但观察到硬盘的写入是30MB/s，那么写放大就是3。写分为<code>立即写</code>和<code>延迟写</code>，比如<code>redo log</code>是立即写，传统基于B-Tree数据库<code>刷脏页</code>和<code>LSM Compaction</code>是延迟写。<code>redo log</code>使用<code>direct IO</code>写时至少以512字节对齐，假如log记录为100字节，磁盘需要写入512字节，写放大为5。</p>
<blockquote>
<p>DirectIO是直接操作IO，不经过BufferIO。<br>BufferIO也称为标准IO，两个系统调用实现的：read() 和 write()。BufferIO用了操作系统内核的页缓存，保护了磁盘，减少读盘的次数，提高了读取速度。但是由于使用了页缓存，它是处于内核空间的，无法被用户直接操作，所以需要经历一次数据拷贝复制。<br>DirectIO 数据均直接在用户地址空间的缓冲区和磁盘之间直接进行传输，中间少了页缓存的支持。读写数据的时候获得更好的性能。使用直接 I/O 读写数据必须要注意缓冲区对齐。</p>
</blockquote>
<h4 id="读放大"><a href="#读放大" class="headerlink" title="读放大"></a>读放大</h4><p>对应于一个简单query需要读取硬盘的次数。比如一个简单query读取了5个页面，发生了5次IO，那么读放大就是 5。假如B-Tree的非叶子节点都缓存在内存中，point read-amp 为1，一次磁盘读取就可以获取到Leaf Block；short range read-amp 为1<del>2，1</del>2次磁盘读取可以获取到所需的Leaf Block。</p>
<p>操作需要从新到旧（从上到下）一层一层查找，直到找到想要的数据。这个过程可能需要<code>不止一次 I/O</code>。特别是 range query 的情况，影响很明显。</p>
<h4 id="空间放大"><a href="#空间放大" class="headerlink" title="空间放大"></a>空间放大</h4><p>假设我需要存储10MB数据，但实际硬盘占用了30MB，那么空间放大就是3。有比较多的因素会影响空间放大，比如在Compaction过程中需要临时存储空间，空间碎片，Block中有效数据的比例小，旧版本数据未及时删除等等。</p>
<p>所有的写入都是顺序写 <code>append-only</code> 的，不是 <code>in-place update</code>，所以过期数据不会马上被清理掉。</p>
<h3 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h3><p>LSM 树的设计思想非常朴素, 它的原理是把一颗大树拆分成N棵小树， 它首先写入到内存中（内存没有寻道速度的问题，随机写的性能得到大幅提升），在内存中构建一颗有序小树，随着小树越来越大，内存的小树会flush到磁盘上。磁盘中的树定期可以做 merge 操作，合并成一棵大树，以优化读性能【读数据的过程可能需要从内存 memtable 到磁盘 sstfile 读取多次，称之为读放大】。RocksDB 的 LSM 体现在多 level 文件格式上，最热最新的数据尽在 L0 层，数据在内存中，最冷最老的数据尽在 LN 层，数据在磁盘或者固态盘上。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/log_structured_merge_tree.png" alt=" LSM合并过程 "></p>
<h3 id="Rocksdb"><a href="#Rocksdb" class="headerlink" title="Rocksdb"></a>Rocksdb</h3><p>RocksDB的三种基本文件格式是 <code>memtable</code> / <code>sstfile</code> / <code>logfile</code>，<code>memtable</code> 是一种内存文件数据系统，新写数据会被写进 <code>memtable</code>，部分请求内容会被写进 <code>logfile</code>。<code>logfile</code> 是一种有利于顺序写的文件系统。<code>memtable</code> 的内存空间被填满之后，会有一部分老数据被转移到 <code>sstfile</code> 里面，这些数据对应的 <code>logfile</code> 里的 <code>log</code> 就会被安全删除</p>
<p>单独的 Get/Put/Delete 是原子操作，要么成功要么失败，不存在中间状态。</p>
<p>如果需要进行批量的 Get/Put/Delete 操作且需要操作保持原子属性，则可以使用 WriteBatch。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/L0.png" alt=" LSM合并过程0 "></p>
<p>L0 -&gt; L1</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/L1.png" alt=" LSM合并过程1 "></p>
<p>L1 -&gt; L2</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/L2.png" alt=" LSM合并过程2 "></p>
<p>L1 -&gt; L2</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/write_process.png" alt=" 写入过程 "></p>
<p>可以看到主要的三个组成部分，内存结构<code>memtable</code>，类似事务日志角色的<code>WAL文件</code>，持久化的<code>SST文件</code>。</p>
<p>数据会放到内存结构<code>memtable</code>，当<code>memtable</code>的数据大小超过阈值(write_buffer_size)后，会<code>新生成一个memtable</code>继续写，将前一个memtable保存为<code>只读memtable</code>。当只读memtable的数量超过阈值后，会将<code>所有的只读memtable</code>合并并flush到磁盘生成一个<code>SST文件</code>。</p>
<p>这里的SST属于level0， level0中的每个SST有序，可能会有交叉。写入WAL文件是<code>可选的</code>，用来<code>恢复未写入到磁盘的memtable</code>。</p>
<p>memtable如其名为一种内存的数据结构。通过设置memtable的大小、总大小来控制何时flush到SST文件。大部分格式的memtable不支持并发写入，并发调用依然会依次写入。目前仅支持<code>skiplist</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rocksdb:</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">    <span class="comment"># 如果数据库不存在是否自动建立</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">create.if.missing:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 如果数据库已经存在是否直接抛出异常</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">error.if.exists:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">paranoid.checks:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 日志等级</span></span><br><span class="line">    <span class="comment"># Debug = 0/Info  = 1/Warn  = 2/Error = 3/Fatal = 4</span></span><br><span class="line">    <span class="attr">info.log.level:</span> <span class="number">3</span></span><br><span class="line">    <span class="comment"># 最佳值是内核（cpu）数</span></span><br><span class="line">    <span class="comment"># 默认RocksDB只使用一个后台线程进行flush和compaction</span></span><br><span class="line">    <span class="comment"># default: 1</span></span><br><span class="line">    <span class="attr">increase.parallelism:</span> <span class="number">4</span></span><br><span class="line">    <span class="comment"># 是否允许并发写入memtabe，目前仅支持skiplist</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">allow.concurrent.memtable.writes:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 更大的值可以提高性能，特别是在批量加载时</span></span><br><span class="line">    <span class="comment"># 此外，更大的写缓冲区在下次打开数据库时将导致更长的恢复时间</span></span><br><span class="line">    <span class="attr">write.buffer.size:</span> <span class="number">64</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">*</span> <span class="number">1024</span></span><br><span class="line">    <span class="comment"># 最大写缓冲区数, 当一个写缓冲区被刷新到存储时，新的写操作可以继续到另一个写缓冲区</span></span><br><span class="line">    <span class="comment"># default: 2</span></span><br><span class="line">    <span class="attr">max.write.buffer.number:</span> <span class="number">4</span></span><br><span class="line">    <span class="attr">min.write.buffer.number.to.merge:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">max.open.files:</span> <span class="number">1000</span></span><br><span class="line">    <span class="attr">max.file.opening.threads:</span> <span class="number">16</span></span><br><span class="line">    <span class="comment"># 数据压缩方式</span></span><br><span class="line">    <span class="comment"># No = 0/ Snappy = 1 / ZLib = 2 / Bz2 = 3 / LZ4 = 4 / LZ4HC = 5 / Xpress = 6 / ZSTD = 7</span></span><br><span class="line">    <span class="attr">compression:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 设置数据库的level的数量</span></span><br><span class="line">    <span class="comment"># 默认值为7层</span></span><br><span class="line">    <span class="attr">num.levels:</span> <span class="number">7</span></span><br><span class="line">    <span class="comment"># level-0 触发合并的的文件数条件</span></span><br><span class="line">    <span class="attr">level0.file.num.compaction.trigger:</span> <span class="number">4</span></span><br><span class="line">    <span class="comment"># level-0 放慢写入速度的文件数条件</span></span><br><span class="line">    <span class="attr">level0.slowdown.writes.trigger:</span> <span class="number">8</span></span><br><span class="line">    <span class="comment"># level-0 停止写入的文件数条件</span></span><br><span class="line">    <span class="attr">level0.stop.writes.trigger:</span> <span class="number">12</span></span><br><span class="line">    <span class="comment"># 尝试从mem到sst的最大级别</span></span><br><span class="line">    <span class="attr">max.mem.compaction.level:</span> <span class="number">2</span></span><br><span class="line">    <span class="comment"># 目标文件基础大小</span></span><br><span class="line">    <span class="comment"># 如果 target_file_size_base是2MB,</span></span><br><span class="line">    <span class="comment"># target_file_size_multiplier是10，</span></span><br><span class="line">    <span class="comment"># 那么第1级的每个文件都是2MB</span></span><br><span class="line">    <span class="comment"># 第2级的每个文件是20MB</span></span><br><span class="line">    <span class="comment"># 第3级的每个文件是200MB</span></span><br><span class="line">    <span class="attr">target.file.size.base:</span> <span class="string">&amp;target_file_size_base</span> <span class="number">2</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">*</span> <span class="number">1024</span></span><br><span class="line">    <span class="comment"># 目标基础文件倍数</span></span><br><span class="line">    <span class="attr">target.file.size.multiplier:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 所在level所有文件总大小</span></span><br><span class="line">    <span class="comment"># 例如，max_bytes_for_level_base为20MB,</span></span><br><span class="line">    <span class="comment"># max_bytes_for_level_multiplier为10，则第1级的总数据大小为20MB</span></span><br><span class="line">    <span class="comment"># 第2级的总文件大小为200MB</span></span><br><span class="line">    <span class="comment"># 第3级的总文件大小为2GB</span></span><br><span class="line">    <span class="comment"># default: 10M</span></span><br><span class="line">    <span class="attr">max.bytes.for.level.base:</span> <span class="number">10</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">*</span> <span class="number">1024</span></span><br><span class="line">    <span class="comment"># 目标所在level总文件大小</span></span><br><span class="line">    <span class="comment"># default: 10</span></span><br><span class="line">    <span class="attr">max.bytes.for.level.multiplier:</span> <span class="number">10.0</span></span><br><span class="line">    <span class="attr">level.compaction.dynamic.level.bytes:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 一次性最大打压缩字节</span></span><br><span class="line">    <span class="comment"># Default: target.file.size.base * 25</span></span><br><span class="line">    <span class="attr">max.compaction.bytes:</span> <span class="string">*target_file_size_base</span> <span class="string">*</span> <span class="number">25</span></span><br><span class="line">    <span class="comment"># 软限制：当需要压缩的估计字节数超过这个阈值时，所有的写都会被减速到至少 delayed_write_rate</span></span><br><span class="line">    <span class="comment"># default: 64GB</span></span><br><span class="line">    <span class="attr">soft.pending.compaction.bytes.limit:</span> <span class="number">64</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">*</span> <span class="number">1024</span></span><br><span class="line">    <span class="comment"># 硬限制：当需要压缩的估计字节数超过这个阈值时，所有的写都停止</span></span><br><span class="line">    <span class="comment"># default: 256GB</span></span><br><span class="line">    <span class="attr">hard.pending.compaction.bytes.limit:</span> <span class="number">256</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">*</span> <span class="number">1024</span></span><br><span class="line">    <span class="comment"># 是否使用fsync刷盘</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">use.fsync:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 指定数据库的日志目录的绝对路径，如果为空则和数据放在同一个目录</span></span><br><span class="line">    <span class="comment"># default: empty</span></span><br><span class="line">    <span class="attr">db.log.dir:</span> <span class="string">""</span></span><br><span class="line">    <span class="comment"># 指定数据库的WAL(预写入日志)的目录的绝对路径，如果为空则和数据放在同一个目录</span></span><br><span class="line">    <span class="attr">wal.dir:</span> <span class="string">""</span></span><br><span class="line">    <span class="comment"># 设置过期文件被删除的周期</span></span><br><span class="line">    <span class="comment"># 通过压缩过程超出作用域的文件在每次压缩时仍然会被自动删除，不管这个设置是什么</span></span><br><span class="line">    <span class="comment"># default: 6 hours</span></span><br><span class="line">    <span class="attr">delete.obsolete.files.period.micros:</span> <span class="number">6</span> <span class="string">*</span> <span class="number">60</span> <span class="string">*</span> <span class="number">60</span> <span class="string">*</span> <span class="number">1000</span> <span class="string">*</span> <span class="number">1000</span></span><br><span class="line">    <span class="comment"># 设置后台任务的最大并发数，作用与低优先级线程池</span></span><br><span class="line">    <span class="comment"># default: 1</span></span><br><span class="line">    <span class="attr">max.background.compactions:</span> <span class="number">2</span></span><br><span class="line">    <span class="comment"># 高优先级线程池的后台 memtable 的 flush 任务的最大并发数</span></span><br><span class="line">    <span class="comment"># 默认所有任务都在低优先级池</span></span><br><span class="line">    <span class="comment"># default: 0</span></span><br><span class="line">    <span class="attr">max.background.flushes:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 设置日志文件的最大大小，如果日志文件大于这个值将会被创建一个新的日志文件</span></span><br><span class="line">    <span class="comment"># 如果等于0，则日志只会写入一个日志文件</span></span><br><span class="line">    <span class="comment"># default: 0</span></span><br><span class="line">    <span class="attr">max.log.file.size:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 日志文件滚动的时间(以秒为单位)，日志按一定时间轮转</span></span><br><span class="line">    <span class="comment"># default: 0 (禁用状态)</span></span><br><span class="line">    <span class="attr">log.file.time.to.roll:</span> <span class="number">24</span> <span class="string">*</span> <span class="number">60</span> <span class="string">*</span> <span class="number">60</span></span><br><span class="line">    <span class="comment"># 最多保留的日志文件数</span></span><br><span class="line">    <span class="comment"># default: 1000</span></span><br><span class="line">    <span class="attr">keep.log.file.num:</span> <span class="number">30</span></span><br><span class="line">    <span class="comment"># 软速率限制</span></span><br><span class="line">    <span class="comment"># 当任何level的压缩分数超过soft_rate_limit时，put被延迟0-1毫秒。当 等于 0.0时，此参数将被忽略</span></span><br><span class="line">    <span class="comment"># soft_rate_limit &lt;= hard_rate_limit。如果此约束不存在，RocksDB将设置soft_rate_limit = hard_rate_limit</span></span><br><span class="line">    <span class="comment"># default: 0.0(禁用状态)</span></span><br><span class="line">    <span class="attr">soft.rate.limit:</span> <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 硬速率限制</span></span><br><span class="line">    <span class="comment"># 当任何level的压缩分数超过hard_rate_limit时，put每次延迟1ms。当 小于等于 1.0 时，此参数被忽略</span></span><br><span class="line">    <span class="comment"># default: 0.0(禁用状态)</span></span><br><span class="line">    <span class="attr">hard.rate.limit:</span> <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 设置当强制执行hard_rate_limit时，put被停止的最大时间, 0 = 没有限制</span></span><br><span class="line">    <span class="comment"># default: 1000</span></span><br><span class="line">    <span class="attr">rate.limit.delay.max.milliseconds:</span> <span class="number">1000</span></span><br><span class="line">    <span class="comment"># 设置最大清单文件大小，直到滚动为止, 会删除旧的清单文件</span></span><br><span class="line">    <span class="comment"># 默认值:MAX_INT，这样滚动就不会发生</span></span><br><span class="line">    <span class="attr">max.manifest.file.size:</span> <span class="number">1</span><span class="string">&lt;&lt;64</span> <span class="bullet">-</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 设置表缓存使用的分片数量</span></span><br><span class="line">    <span class="comment"># default: 4</span></span><br><span class="line">    <span class="attr">table.cache.numshardbits:</span> <span class="number">4</span></span><br><span class="line">    <span class="comment"># 设置扫描过程中的计数限制</span></span><br><span class="line">    <span class="comment"># 在表的LRU缓存数据回收时，严格遵循LRU是低效的，因为这块内存不会真正被释放，除非它的refcount降到零。</span></span><br><span class="line">    <span class="comment"># 相反，进行两次传递:第一次传递将释放refcount = 1的项，如果在扫描该参数指定的元素数量后没有足够的空间释放，将按LRU顺序删除项</span></span><br><span class="line">    <span class="comment"># default: 16</span></span><br><span class="line">    <span class="attr">table.cache.remove.scan.count.limit:</span> <span class="number">16</span></span><br><span class="line">    <span class="comment"># default: 0 (自动计算一个合适的值)</span></span><br><span class="line">    <span class="attr">arena.block.size:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 启用/禁用自动压缩</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">disable.auto.compactions:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 设置 Wal 的恢复模式</span></span><br><span class="line">    <span class="comment"># TolerateCorruptedTailRecordsRecovery = 0 / AbsoluteConsistencyRecovery = 1</span></span><br><span class="line">    <span class="comment"># PointInTimeRecovery = 2 / SkipAnyCorruptedRecordsRecovery = 3</span></span><br><span class="line">    <span class="comment"># default: 0</span></span><br><span class="line">    <span class="attr">w.a.l.recovery.mode:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 设置wal的ttl时间</span></span><br><span class="line">    <span class="comment"># 有2个值影响 归档的 wal 是否会被删除</span></span><br><span class="line">    <span class="comment"># 1。如果两者都设置为0，日志将被尽快删除，并且不会进入存档。</span></span><br><span class="line">    <span class="comment"># 2。如果wal_ttl_seconds为0,wal_size_limit_mb不为0，则每10分钟检查一次WAL文件，如果总大小大于wal_size_limit_mb，则从最早的文件开始删除，直到满足size_limit。所有的空文件将被删除。</span></span><br><span class="line">    <span class="comment"># 3。如果wal_ttl_seconds不为0,wall_size_limit_mb为0，那么每个wal_ttl_seconds / 2都会检查WAL文件，比wal_ttl_seconds老的文件会被删除。</span></span><br><span class="line">    <span class="comment"># 4。如果两个都不是0，则每10分钟检查一次WAL文件，并且两个检查都将在ttl优先的情况下执行。</span></span><br><span class="line">    <span class="comment"># default: 0</span></span><br><span class="line">    <span class="attr">w.a.l.ttl.seconds:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 设置WAL大小限制，单位为MB</span></span><br><span class="line">    <span class="comment"># 如果WAL文件的总大小大于wal_size_limit_mb，则从最早的文件开始删除，直到满足size_limit值为止</span></span><br><span class="line">    <span class="comment"># default: 0</span></span><br><span class="line">    <span class="attr">wal.size.limit.mb:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 允许管道写入</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">enable.pipelined.write:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 设置预分配(通过fallocate) manifest文件的字节数</span></span><br><span class="line">    <span class="comment"># 默认值是4mb，这对于减少随机IO以及防止预分配大量数据的挂载(例如xfs的allocsize选项)过度分配是合理的</span></span><br><span class="line">    <span class="comment"># default: 4mb</span></span><br><span class="line">    <span class="attr">manifest.preallocation.size:</span> <span class="number">1024</span> <span class="string">*</span> <span class="number">1024</span> <span class="string">*</span> <span class="number">4</span></span><br><span class="line">    <span class="comment"># 当memtable被刷新到存储中时[启用|禁用] 清除 [重复\被删除]的 键</span></span><br><span class="line">    <span class="comment"># default: true</span></span><br><span class="line">    <span class="attr">purge.redundant.kvs.while.flush:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 开启/关闭sst表的mmap读功能</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">allow.mmap.reads:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 开启/关闭sst表的mmap写功能</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">allow.mmap.writes:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 启用/禁用读操作的直接I/O模式(O_DIRECT)</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">use.direct.reads:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 启用/禁用后台flush和compaction的直接I/O模式(O_DIRECT)</span></span><br><span class="line">    <span class="comment"># 当为true时，new_table_reader_for_compaction_inputs被强制为true。</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">use.direct.i.o.for.flush.and.compaction:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># [开启|禁用] 子进程继承打开的文件</span></span><br><span class="line">    <span class="comment"># default: true</span></span><br><span class="line">    <span class="attr">is.fd.close.on.exec:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># [启用|禁用]在恢复时跳过日志损坏错误(如果客户端可以丢失最近的更改)</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">skip.log.error.on.recovery:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 设置统计转储周期，以秒为单位</span></span><br><span class="line">    <span class="comment"># default: 3600 (1 hour)</span></span><br><span class="line">    <span class="attr">stats.dump.period.sec:</span> <span class="number">3600</span></span><br><span class="line">    <span class="comment"># 当打开sst文件时，是否会提示底层文件系统文件访问模式是随机的</span></span><br><span class="line">    <span class="comment"># default: true</span></span><br><span class="line">    <span class="attr">advise.random.on.open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 设置所有列族写入磁盘之前在memtables中建立的数据量。</span></span><br><span class="line">    <span class="comment"># 这与write_buffer_size不同，后者强制对单个memtable进行限制</span></span><br><span class="line">    <span class="comment"># default: 0(禁用)</span></span><br><span class="line">    <span class="attr">db.write.buffer.size:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 压缩启动后的文件访问模式</span></span><br><span class="line">    <span class="comment"># NoneCompactionAccessPattern = 0, NormalCompactionAccessPattern = 1</span></span><br><span class="line">    <span class="comment"># SequentialCompactionAccessPattern = 2, WillneedCompactionAccessPattern = 3</span></span><br><span class="line">    <span class="comment"># default: NormalCompactionAccessPattern</span></span><br><span class="line">    <span class="attr">access.hint.on.compaction.start:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 启用/禁用自适应互斥锁，它在求助于内核之前在用户空间旋转</span></span><br><span class="line">    <span class="comment"># 当互斥锁不是严重竞争时，可以减少上下文切换。但是，如果互斥对象是热的，最终可能会浪费旋转时间</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">use.adaptive.mutex:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 允许操作系统在后台异步写入文件时增量同步文件到磁盘</span></span><br><span class="line">    <span class="comment"># 对每写一个bytes_per_sync发出一个请求。</span></span><br><span class="line">    <span class="comment"># default: 0(禁用)</span></span><br><span class="line">    <span class="attr">bytes.per.sync:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 设置压缩样式</span></span><br><span class="line">    <span class="comment"># LevelCompactionStyle = 0 / UniversalCompactionStyle = 1 / FIFOCompactionStyle = 2</span></span><br><span class="line">    <span class="comment"># default: LevelCompactionStyle</span></span><br><span class="line">    <span class="attr">compaction.style:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 指定迭代-&gt;Next()是否按顺序跳过具有相同user-key的键</span></span><br><span class="line">    <span class="comment"># 这个数字指定在重寻之前将被连续跳过的键数(与userkey相同)</span></span><br><span class="line">    <span class="comment"># default: 8</span></span><br><span class="line">    <span class="attr">max.sequential.skip.in.iterations:</span> <span class="number">8</span></span><br><span class="line">    <span class="comment">#[启用|禁用]线程安全的就地更新</span></span><br><span class="line">    <span class="comment"># default: false</span></span><br><span class="line">    <span class="attr">inplace.update.support:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 用于就地更新的锁的数量</span></span><br><span class="line">    <span class="comment"># default: 0, ，如果 inplace_update_support = true ，则为 10000</span></span><br><span class="line">    <span class="attr">inplace.update.num.locks:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 设置memtable使用的arena的大页大小</span></span><br><span class="line">    <span class="comment"># 如果&lt;=0，它不会从大页分配，而是从malloc分配。用户有责任为它预留巨大的页面以供分配。</span></span><br><span class="line">    <span class="comment"># 例如:sysctl -w vm.nr_hugepages=20</span></span><br><span class="line">    <span class="comment"># 参见linux doc Documentation/vm/hugetlbpage.txt</span></span><br><span class="line">    <span class="comment"># 如果没有足够的空闲大页，它会退回到malloc</span></span><br><span class="line">    <span class="comment"># 通过SetOptions() API动态更改</span></span><br><span class="line">    <span class="attr">memtable.huge.page.size:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 设置布隆过滤器的指针位置</span></span><br><span class="line">    <span class="comment"># 控制bloom filter探针的位置，以提高缓存遗漏率。</span></span><br><span class="line">    <span class="comment"># 该选项仅适用于memtable前缀bloom和plain前缀bloom。</span></span><br><span class="line">    <span class="comment"># 它本质上限制了每个bloom filter检查可以触及的缓存线的最大数量。</span></span><br><span class="line">    <span class="comment"># 设置为0时，此优化被关闭。这个数目不应该大于探测的数目。</span></span><br><span class="line">    <span class="comment"># 这个选项可以提高内存工作负载的性能，但应该小心使用，因为它可能会导致更高的误报率。</span></span><br><span class="line">    <span class="comment"># default: 0</span></span><br><span class="line">    <span class="attr">bloom.locality:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 设置memtable中一个键的最大连续合并操作数</span></span><br><span class="line">    <span class="comment"># default: 0 (禁用状态)</span></span><br><span class="line">    <span class="attr">max.successive.merges:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 开启统计</span></span><br><span class="line">    <span class="comment"># default: 无参数，false代表不启动，true则会调用对应的api</span></span><br><span class="line">    <span class="attr">enable.statistics:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 预加载数据库为了批量加载</span></span><br><span class="line">    <span class="comment"># 所有数据将在0级没有任何自动压缩</span></span><br><span class="line">    <span class="comment"># 建议在从数据库读取数据之前手动调用CompactRange(NULL, NULL)，否则读取速度会非常慢</span></span><br><span class="line">    <span class="comment"># default: 无参数，false代表不启动，true则会调用对应的api</span></span><br><span class="line">    <span class="attr">prepare.for.bulk.load:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 设置一个MemTableRep，它由一个向量支持</span></span><br><span class="line">    <span class="comment"># 在迭代时，向量被排序，这对于迭代非常少且读操作开始后通常不执行写操作的工作负载非常有用</span></span><br><span class="line">    <span class="comment"># default: 无参数，false代表不启动，true则会调用对应的api</span></span><br><span class="line">    <span class="attr">memtable.vector.rep:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 如果不存在列族是否自动建立</span></span><br><span class="line">    <span class="comment"># default: true</span></span><br><span class="line">    <span class="attr">create.if.missing.column.families:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="SQL-AST的支持"><a href="#SQL-AST的支持" class="headerlink" title="SQL-AST的支持"></a>SQL-AST的支持</h2><p>我们的db希望能做到与语言无关，不仅仅是我们的目前的golang，就算是php也可以用到本地持久化的方式的话，就需要借助<code>RPC协议</code>或者<code>特定DSL</code>来实现，但是既然是数据库，这里优先选择了以<code>sql语法</code>来管理数据。</p>
<p>那么我们就需要拿到<code>sql</code>的抽象语法树(<code>sql-ast</code>)，拿到<code>sql-ast</code>之后，我们就可以拿到我们所需要的信息去<code>hit data</code>。</p>
<p><a href="github.com/pingcap/parser">Pingcap-parser</a></p>
<p>这里我们用到了pingcap公司的<code>parser</code>库，该库同样是<code>TiDB</code>的sql解析库，借助该库，我们可以很方便的拿到<code>sql-ast</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/pingcap/parser"</span></span><br><span class="line">	_ <span class="string">"github.com/pingcap/parser/test_driver"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> visitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	table  <span class="keyword">string</span></span><br><span class="line">	fields []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *visitor)</span> <span class="title">Enter</span><span class="params">(in ast.Node)</span> <span class="params">(out ast.Node, skipChildren <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//fmt.Printf("Enter: %T\n", in)</span></span><br><span class="line">	<span class="keyword">switch</span> n := in.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *ast.SelectStmt:</span><br><span class="line">	<span class="keyword">case</span> *ast.FieldList:</span><br><span class="line">	<span class="keyword">case</span> *ast.SelectField:</span><br><span class="line">	<span class="keyword">case</span> *ast.ColumnNameExpr:</span><br><span class="line">		<span class="comment">//fmt.Printf("Enter: %v\n", n.Name)</span></span><br><span class="line">	<span class="keyword">case</span> *ast.ColumnName:</span><br><span class="line">		<span class="comment">//v.fields = append(v.fields, n.Name.L)</span></span><br><span class="line">	<span class="keyword">case</span> *ast.TableName:</span><br><span class="line">		<span class="comment">//v.table = n.Name.L</span></span><br><span class="line">	<span class="keyword">case</span> *ast.BinaryOperationExpr:</span><br><span class="line">		<span class="comment">//fmt.Printf("Enter: %v\n", n.Op)</span></span><br><span class="line">	<span class="keyword">case</span> *ast.Join:</span><br><span class="line">		<span class="comment">//fmt.Printf("Enter: %v\n", n.Left)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> in, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *visitor)</span> <span class="title">Leave</span><span class="params">(in ast.Node)</span> <span class="params">(out ast.Node, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Leave: %T\n"</span>, in)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> n := in.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *ast.SelectStmt:</span><br><span class="line">	<span class="keyword">case</span> *ast.FieldList:</span><br><span class="line">	<span class="keyword">case</span> *ast.SelectField:</span><br><span class="line">	<span class="keyword">case</span> *ast.ColumnNameExpr:</span><br><span class="line">	<span class="keyword">case</span> *ast.ColumnName:</span><br><span class="line">	<span class="keyword">case</span> *ast.TableName:</span><br><span class="line">		v.table = n.Name.L</span><br><span class="line">	<span class="keyword">case</span> *ast.BinaryOperationExpr:</span><br><span class="line">		<span class="comment">//fmt.Printf("Leave: %v\n", n.L)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> in, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := parser.New()</span><br><span class="line"></span><br><span class="line">	sql := <span class="string">"SELECT emp_no, first_name, last_name "</span> +</span><br><span class="line">		<span class="string">"FROM employees "</span> +</span><br><span class="line">		<span class="string">"where id='Aamodt' and (create_time &gt; 0 or last_name ='caiwenhui')"</span></span><br><span class="line">	stmtNodes, _, err := p.Parse(sql, <span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"parse error:\n%v\n%s"</span>, err, sql)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> _, stmtNode := <span class="keyword">range</span> stmtNodes &#123;</span><br><span class="line">		v := visitor&#123;&#125;</span><br><span class="line">		stmtNode.Accept(&amp;v)</span><br><span class="line">		fmt.Printf(<span class="string">"%v\n"</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了<code>github.com/pingcap/parser/test_driver</code> 的原因是因为该库和tidb的driver存在依赖关系，tidb在设计的时候，并未做到很好的分离，所以当其他项目需要使用该库的时候，需要引入这个驱动。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Visitor visits a Node.</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Enter is called before children nodes are visited.</span></span><br><span class="line">	<span class="comment">// The returned node must be the same type as the input node n.</span></span><br><span class="line">	<span class="comment">// skipChildren returns true means children nodes should be skipped,</span></span><br><span class="line">	<span class="comment">// this is useful when work is done in Enter and there is no need to visit children.</span></span><br><span class="line">	Enter(n Node) (node Node, skipChildren <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// Leave is called after children nodes have been visited.</span></span><br><span class="line">	<span class="comment">// The returned node's type can be different from the input node if it is a ExprNode,</span></span><br><span class="line">	<span class="comment">// Non-expression node must be the same type as the input node n.</span></span><br><span class="line">	<span class="comment">// ok returns false to stop visiting.</span></span><br><span class="line">	Leave(n Node) (node Node, ok <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且这里，我们看到有一个结构体<code>visitor</code>，该结构体就是用来访问<code>ast</code>用的，因为 <code>tidb</code>的<code>parser库</code> 和<code>阿里巴巴</code> 的 <code>druid sql</code> 类似，都是采用 访问器的方式来遍历 <code>ast</code>的，所以我们只需要定义好我们的访问器，那么就可以访问对应的结构数据。<br>至于访问器的接口如上图，只有2个API，一个是 <code>Enter(n Node) (node Node, skipChildren bool)</code>，另外一个是 <code>Leave(n Node) (node Node, ok bool)</code> 。2个接口返回的第二个参数分别定义为 <code>是否跳过剩下的节点</code>, <code>是否成功退出节点</code>。</p>
<h3 id="interface在这里的应用"><a href="#interface在这里的应用" class="headerlink" title="interface在这里的应用"></a>interface在这里的应用</h3><p>在parser中，大量运用了interface, 充分的给我们的展示了golang的<code>组合</code>特性。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node is the basic element of the AST.</span></span><br><span class="line"><span class="comment">// Interfaces embed Node should have 'Node' name suffix.</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Restore returns the sql text from ast tree</span></span><br><span class="line">	Restore(ctx *format.RestoreCtx) error</span><br><span class="line">	<span class="comment">// Accept accepts Visitor to visit itself.</span></span><br><span class="line">	<span class="comment">// The returned node should replace original node.</span></span><br><span class="line">	<span class="comment">// ok returns false to stop visiting.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Implementation of this method should first call visitor.Enter,</span></span><br><span class="line">	<span class="comment">// assign the returned node to its method receiver, if skipChildren returns true,</span></span><br><span class="line">	<span class="comment">// children should be skipped. Otherwise, call its children in particular order that</span></span><br><span class="line">	<span class="comment">// later elements depends on former elements. Finally, return visitor.Leave.</span></span><br><span class="line">	Accept(v Visitor) (node Node, ok <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// Text returns the original text of the element.</span></span><br><span class="line">	Text() <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// SetText sets original text to the Node.</span></span><br><span class="line">	SetText(text <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SelectStmt represents the select query node.</span></span><br><span class="line"><span class="comment">// See https://dev.mysql.com/doc/refman/5.7/en/select.html</span></span><br><span class="line"><span class="keyword">type</span> SelectStmt <span class="keyword">struct</span> &#123;</span><br><span class="line">	dmlNode</span><br><span class="line">	resultSetNode</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SelectStmtOpts wraps around select hints and switches.</span></span><br><span class="line">	*SelectStmtOpts</span><br><span class="line">	<span class="comment">// Distinct represents whether the select has distinct option.</span></span><br><span class="line">	Distinct <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// From is the from clause of the query.</span></span><br><span class="line">	From *TableRefsClause</span><br><span class="line">	<span class="comment">// Where is the where clause in select statement.</span></span><br><span class="line">	Where ExprNode</span><br><span class="line">	<span class="comment">// Fields is the select expression list.</span></span><br><span class="line">	Fields *FieldList</span><br><span class="line">	<span class="comment">// GroupBy is the group by expression list.</span></span><br><span class="line">	GroupBy *GroupByClause</span><br><span class="line">	<span class="comment">// Having is the having condition.</span></span><br><span class="line">	Having *HavingClause</span><br><span class="line">	<span class="comment">// WindowSpecs is the window specification list.</span></span><br><span class="line">	WindowSpecs []WindowSpec</span><br><span class="line">	<span class="comment">// OrderBy is the ordering expression list.</span></span><br><span class="line">	OrderBy *OrderByClause</span><br><span class="line">	<span class="comment">// Limit is the limit clause.</span></span><br><span class="line">	Limit *Limit</span><br><span class="line">	<span class="comment">// LockTp is the lock type</span></span><br><span class="line">	LockTp SelectLockType</span><br><span class="line">	<span class="comment">// TableHints represents the table level Optimizer Hint for join type</span></span><br><span class="line">	TableHints []*TableOptimizerHint</span><br><span class="line">	<span class="comment">// IsAfterUnionDistinct indicates whether it's a stmt after "union distinct".</span></span><br><span class="line">	IsAfterUnionDistinct <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// IsInBraces indicates whether it's a stmt in brace.</span></span><br><span class="line">	IsInBraces <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// QueryBlockOffset indicates the order of this SelectStmt if counted from left to right in the sql text.</span></span><br><span class="line">	QueryBlockOffset <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// SelectIntoOpt is the select-into option.</span></span><br><span class="line">	SelectIntoOpt *SelectIntoOption</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">splitWhere</span><span class="params">(where ast.ExprNode)</span> []<span class="title">ast</span>.<span class="title">ExprNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> conditions []ast.ExprNode</span><br><span class="line">	<span class="keyword">switch</span> x := where.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">	<span class="keyword">case</span> *ast.BinaryOperationExpr:</span><br><span class="line">		<span class="keyword">if</span> x.Op == opcode.LogicAnd &#123;</span><br><span class="line">			conditions = <span class="built_in">append</span>(conditions, splitWhere(x.L)...)</span><br><span class="line">			conditions = <span class="built_in">append</span>(conditions, splitWhere(x.R)...)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			conditions = <span class="built_in">append</span>(conditions, x)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> *ast.ParenthesesExpr:</span><br><span class="line">		conditions = <span class="built_in">append</span>(conditions, splitWhere(x.Expr)...)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		conditions = <span class="built_in">append</span>(conditions, where)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> conditions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ast.Node</code> 是ast的基础接口，所有的节点都需要在此之上实现自己的功能。其他接口同理，一环扣一环，设计得十分巧妙。</p>
<h2 id="KEY-VALUE的编码规则"><a href="#KEY-VALUE的编码规则" class="headerlink" title="KEY-VALUE的编码规则"></a>KEY-VALUE的编码规则</h2><p>DB 对每个表分配一个 TableID，每一个索引都会分配一个 IndexID，每一行分配一个 RowID， 其中 DbId/TableID 在整个集群内唯一，IndexID/RowID 在表内唯一，这些 ID 都是 int64 类型。</p>
<p>其中细节如下：</p>
<p>database 编码成 Key-Value pair：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key: metaPrefix(+)databasePrefix&#123;dbID&#125;</span><br><span class="line">Value: database struct json marshal</span><br></pre></td></tr></table></figure>

<p>database indexed 编码成 Key-Value pair：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key: metaPrefix(+)databasePrefix_indexPrefix&#123;database_name&#125;</span><br><span class="line">Value: dbID</span><br></pre></td></tr></table></figure>

<p>table 编码成 Key-Value pair：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key: metaPrefix(+)tablePrefix&#123;dbID&#125;_recordPrefixSep&#123;tableID&#125;</span><br><span class="line">Value: table struct json marshal</span><br></pre></td></tr></table></figure>

<p>table indexed 编码成 Key-Value pair：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key: metaPrefix(+)tablePrefix&#123;dbID&#125;_indexPrefix&#123;databaseId&#125;&#123;table_name&#125;</span><br><span class="line">Value: tableID</span><br></pre></td></tr></table></figure>

<p>每行数据按照如下规则进行编码成 Key-Value pair：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key: databasePrefix&#123;dbID&#125;_tablePrefix&#123;tableID&#125;_recordPrefixSep&#123;rowID&#125;</span><br><span class="line">Value: [col1, col2, col3, col4]</span><br></pre></td></tr></table></figure>

<p>对于 Unique Index 数据，会按照如下规则编码成 Key-Value pair：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key: databasePrefix&#123;dbID&#125;_tablePrefix&#123;tableID&#125;_indexPrefixSep&#123;indexID&#125;_indexedColumnsValue</span><br><span class="line">Value: rowID</span><br></pre></td></tr></table></figure>

<p>Index 数据还需要考虑 Unique Index 和非 Unique Index 两种情况，对于 Unique Index，可以按照上述编码规则。 但是对于非 Unique Index，通过这种编码并不能构造出唯一的 Key，因为同一个<br>Index 的 <code>databasePrefix{dbID}_tablePrefix{tableID}_indexPrefixSep{indexID}</code>都一样，可能有多行数据的 ColumnsValue 是一样的.</p>
<p>对于 “非” Unique Index 的编码做了一点调整：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key: databasePrefix&#123;dbID&#125;_tablePrefix&#123;tableID&#125;_indexPrefixSep&#123;indexID&#125;_indexedColumnsValue_&#123;rowID&#125;</span><br><span class="line">Value: null</span><br></pre></td></tr></table></figure>

<p>对应的标识符如下定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	databasePrefix  = []<span class="keyword">byte</span>&#123;<span class="string">'d'</span>&#125;</span><br><span class="line">	tablePrefix     = []<span class="keyword">byte</span>&#123;<span class="string">'t'</span>&#125;</span><br><span class="line">	recordPrefixSep = []<span class="keyword">byte</span>(<span class="string">"_r"</span>)</span><br><span class="line">	indexPrefixSep  = []<span class="keyword">byte</span>(<span class="string">"_i"</span>)</span><br><span class="line">	metaPrefix      = []<span class="keyword">byte</span>&#123;<span class="string">'m'</span>&#125;</span><br><span class="line">	sepPrefix       = []<span class="keyword">byte</span>&#123;<span class="string">'_'</span>&#125;</span><br><span class="line"></span><br><span class="line">	mdPrefix  = <span class="built_in">append</span>(metaPrefix, databasePrefix...)</span><br><span class="line">	mdiPrefix = <span class="built_in">append</span>(<span class="built_in">append</span>(metaPrefix, databasePrefix...), indexPrefixSep...)</span><br><span class="line">	mtPrefix  = <span class="built_in">append</span>(metaPrefix, tablePrefix...)</span><br><span class="line">	mtiPrefix = <span class="built_in">append</span>(<span class="built_in">append</span>(metaPrefix, tablePrefix...), indexPrefixSep...)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	idLen                = <span class="number">8</span></span><br><span class="line">	sepPrefixLen         = <span class="number">1</span></span><br><span class="line">	prefixLen            = databasePrefixLength + idLen <span class="comment">/*dbID*/</span> + sepPrefixLen + tablePrefixLength + idLen <span class="comment">/*tableID*/</span> + recordPrefixSepLength</span><br><span class="line">	uniqPrefixLen        = databasePrefixLength + idLen <span class="comment">/*dbID*/</span> + sepPrefixLen + tablePrefixLength + idLen <span class="comment">/*tableID*/</span> + indexPrefixSepLength + idLen <span class="comment">/*indexID*/</span> + sepPrefixLen <span class="comment">/* +indexedColumnsValue */</span></span><br><span class="line">	indexPrefixLen       = databasePrefixLength + idLen <span class="comment">/*dbID*/</span> + sepPrefixLen + tablePrefixLength + idLen <span class="comment">/*tableID*/</span> + indexPrefixSepLength + idLen <span class="comment">/*indexID*/</span> + sepPrefixLen + sepPrefixLen</span><br><span class="line">	indexPrefixLenWithID = databasePrefixLength + idLen <span class="comment">/*dbID*/</span> + sepPrefixLen + tablePrefixLength + idLen <span class="comment">/*tableID*/</span> + indexPrefixSepLength + idLen <span class="comment">/*indexID*/</span> + sepPrefixLen + sepPrefixLen + idLen</span><br><span class="line">	<span class="comment">// RecordRowKeyLen is public for calculating avgerage row size.</span></span><br><span class="line">	RecordRowKeyLen       = prefixLen + idLen <span class="comment">/*handle*/</span></span><br><span class="line">	tablePrefixLength     = <span class="number">1</span></span><br><span class="line">	databasePrefixLength  = <span class="number">1</span></span><br><span class="line">	recordPrefixSepLength = <span class="number">2</span></span><br><span class="line">	indexPrefixSepLength  = <span class="number">2</span></span><br><span class="line">	metaPrefixLength      = <span class="number">1</span></span><br><span class="line">	mdPrefixLen           = metaPrefixLength + databasePrefixLength</span><br><span class="line">	mdiPrefixLen          = mdPrefixLen + indexPrefixSepLength</span><br><span class="line">	mtPrefixLen           = metaPrefixLength + tablePrefixLength</span><br><span class="line">	mtiPrefixLen          = mtPrefixLen + indexPrefixSepLength</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们把rowkey的编码规则来看</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EncodeRowKey encodes the table id and record handle into a kv.Key</span></span><br><span class="line"><span class="comment">// EncodeRowKey databasePrefix&#123;dbID&#125;_tablePrefix&#123;tableID&#125;_recordPrefixSep&#123;rowID&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeRowKey</span><span class="params">(databaseId, tableID, rowId <span class="keyword">int64</span>)</span> <span class="title">kv</span>.<span class="title">Key</span></span> &#123;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, prefixLen+idLen <span class="comment">/*rowId*/</span>)</span><br><span class="line">	buf = <span class="built_in">append</span>(buf, databasePrefix...)</span><br><span class="line">	buf = <span class="built_in">append</span>(buf, EncodeIdBuf(databaseId)...)</span><br><span class="line">	buf = <span class="built_in">append</span>(buf, sepPrefix...)</span><br><span class="line">	buf = <span class="built_in">append</span>(buf, tablePrefix...)</span><br><span class="line">	buf = <span class="built_in">append</span>(buf, EncodeIdBuf(tableID)...)</span><br><span class="line">	buf = <span class="built_in">append</span>(buf, recordPrefixSep...)</span><br><span class="line">	buf = <span class="built_in">append</span>(buf, EncodeIdBuf(rowId)...)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> buf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeIdBuf</span><span class="params">(id <span class="keyword">int64</span>)</span> <span class="title">kv</span>.<span class="title">Key</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">	binary.BigEndian.PutUint64(buf[:], <span class="keyword">uint64</span>(id))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> buf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeIdBuf</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int64</span>(binary.BigEndian.Uint64(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们通过<code>EncodeRowKey(databaseId, tableID, rowId int64) kv.Key</code> 来生成数据的<code>row-key</code>，我们利用<code>make([]byte,0, len)</code> 的方式预申请内存的方式，后面再通过append的方式往 <code>slice</code> 中不断追加字节，当遇到<code>int64</code>的数据的时候，我们会调用<code>EncodeIdBuf(id int64) kv.Key</code> 来把int64转换为 <code>大端(网络字节序)</code> 的二进制字节。最后一个row-key就生成了。</p>
<h3 id="database-编码"><a href="#database-编码" class="headerlink" title="database 编码"></a>database 编码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> database <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int64</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createDatabaseHandle Create database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">createDatabaseHandle</span><span class="params">(result *Result, stmt *ast.CreateDatabaseStmt)</span></span> &#123;</span><br><span class="line">	indexedKey := etccodec.EncodeDatabaseMetaIndexedKey([]<span class="keyword">byte</span>(stmt.Name))</span><br><span class="line">	rdb := rocksdb.Load().(*Rocksdb)</span><br><span class="line">	slice, err := rdb.Get(rdb.NewDefaultReadOptions(), indexedKey)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		errorlog(UnexpectErrorCategory&#123;&#125;, UnknowRCode)</span><br><span class="line">		result.Record(UnknowRCode, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> slice.Exists() &#123;</span><br><span class="line">		<span class="keyword">if</span> !stmt.IfNotExists &#123;</span><br><span class="line">			errorlog(UnexpectErrorCategory&#123;&#125;, DatabaseExistsRCode)</span><br><span class="line">			result.Record(DatabaseExistsRCode, <span class="literal">nil</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result.Success()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dbId, err := getDatabaseId()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"get database id failed, err: %s"</span>, err)</span><br><span class="line">		errorlog(UnexpectErrorCategory&#123;&#125;, msg)</span><br><span class="line">		result.Record(CreateDatabaseFailedRCode, &amp;msg)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	db := &amp;database&#123;</span><br><span class="line">		Id:   dbId,</span><br><span class="line">		Name: stmt.Name,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> buf = etccodec.EncodeIdBuf(dbId)</span><br><span class="line">	key := etccodec.EncodeDatabaseMetaKey(dbId)</span><br><span class="line">	value, err := json.Marshal(db)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"marshal database error, err: %s"</span>, err)</span><br><span class="line">		errorlog(UnexpectErrorCategory&#123;&#125;, msg)</span><br><span class="line">		result.Record(CreateDatabaseFailedRCode, &amp;msg)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = rdb.Put(key, value)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"rocksdb put metadata failed, err: %s"</span>, err)</span><br><span class="line">		errorlog(UnexpectErrorCategory&#123;&#125;, msg)</span><br><span class="line">		result.Record(CreateDatabaseFailedRCode, &amp;msg)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = rdb.Put(indexedKey, buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"rocksdb put indexed failed, err: %s"</span>, err)</span><br><span class="line">		errorlog(UnexpectErrorCategory&#123;&#125;, msg)</span><br><span class="line">		result.Record(CreateDatabaseFailedRCode, &amp;msg)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	debugf(NormalDebugCategory&#123;&#125;, <span class="string">"create database [%s]"</span>, db)</span><br><span class="line">	result.Success()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们借助 <code>create database stmt</code> 来的处理方法来看看 <code>db Key-Value pair</code> 的处理逻辑。<br>我们看到这里，我们通过一个<code>stmt.Name</code> 来拿到数据库的名，并且调用<code>etccodec.EncodeDatabaseMetaIndexedKey([]byte(stmt.Name))</code> 方法来创建符合<code>metaPrefix(+)databasePrefix_indexPrefix{database_name}</code> 索引的key，然后判断是否存在所以索引来判断后续的逻辑。<br>我们通过一个 <code>getDatabaseId()</code> 方法来获取一个全局的数据库id，并且初始化<code>type database struct</code>，然后我们调用了 <code>etccodec.EncodeDatabaseMetaKey(dbid)</code> 来对key进行生成，也就是上面所列出来的 <code>metaPrefix(+)databasePrefix{dbID}</code>, 接下来就是<code>value</code>的生成，这里的value比较直接，就是<code>json.marshal</code>来处理后的字节。然后我们把数据<code>put</code> 到<code>rocksdb</code>就结束了，索引数据也是如此，不过索引存储的dbid。</p>
<blockquote>
<p>table的编码也类似</p>
</blockquote>
<p>如果对其他的<code>stmt</code>，例如<code>insert stmt/delete stmt</code>具体的逻辑感兴趣的话，可以查阅源码，但是类似差不多。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/indexed.png" alt=" indexed "></p>
<h2 id="COUNTER计数器-发号器"><a href="#COUNTER计数器-发号器" class="headerlink" title="COUNTER计数器-发号器"></a>COUNTER计数器-发号器</h2><p>这里我们需要讲一下<code>counter</code>，因为我们所有的数据都会有<code>row_id</code>，并且我们在<code>create table</code>的时候也有<code>AUTO_INCREMENT</code>的列，这个时候，我们也是需要一个ID发号器。</p>
<p>目前常见的发号器实现方案如下：</p>
<ul>
<li><ol>
<li>UUID</li>
</ol>
</li>
<li><ol start="2">
<li>snowflake</li>
</ol>
</li>
<li><ol start="3">
<li>数据库生成</li>
</ol>
</li>
<li><ol start="4">
<li>美团的Leaf（基于数据库）</li>
</ol>
</li>
</ul>
<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>UUID(Universally Unique Identifier)的标准型式包含<code>32个16进制</code>数字，以连字号分为<code>五段</code>，形式为<code>8-4-4-4-12</code>的36个字符，示例：<code>550e8400-e29b-41d4-a716-446655440000</code>，到目前为止业界一共有5种方式生成UUID，详情见IETF发布的UUID规范 <a href="https://www.ietf.org/rfc/rfc4122.txt" target="_blank" rel="noopener">A Universally Unique IDentifier (UUID) URN Namespace</a></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/uuid.png" alt=" UUID "></p>
<blockquote>
<p>由于他的无序性，不符合我们所期待的增长序列，所以抛弃</p>
</blockquote>
<h3 id="类snowflake方案"><a href="#类snowflake方案" class="headerlink" title="类snowflake方案"></a>类snowflake方案</h3><p>这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等，比如在snowflake中的64-bit分别表示如下图所示：</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/snowflake.png" alt=" snowflake "></p>
<blockquote>
<p>生成繁琐，由多个指令码组成，并且我们不需要用到分布式，这个还对本地的时间有强依赖，不够简洁</p>
</blockquote>
<h3 id="基于数据库的"><a href="#基于数据库的" class="headerlink" title="基于数据库的"></a>基于数据库的</h3><p>基于数据库的其实就是利用自增的自增机制+发号机制的组合，但是由于我们这里不基于数据库，所以给予数据库的基本也不考虑，但是其中的发号机制可以参考。例如：预分配机制。</p>
<h3 id="自己的发号器"><a href="#自己的发号器" class="headerlink" title="自己的发号器"></a>自己的发号器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> msource</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/gorocksdb"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/signal"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	*gorocksdb.ReadOptions</span><br><span class="line"></span><br><span class="line">	IdKey []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	GroupId <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	idChan <span class="keyword">chan</span> <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	sig <span class="keyword">chan</span> os.Signal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	c.IdKey = data[<span class="number">1</span> : <span class="built_in">len</span>(data)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">	turboNew(c)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(c.IdKey)+<span class="number">2</span>)</span><br><span class="line">	b = <span class="built_in">append</span>(b, <span class="string">'"'</span>)</span><br><span class="line">	b = <span class="built_in">append</span>(b, c.IdKey...)</span><br><span class="line">	b = <span class="built_in">append</span>(b, <span class="string">'"'</span>)</span><br><span class="line">	<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(c).Elem()</span><br><span class="line">	v := reflect.ValueOf(c).Elem()</span><br><span class="line">	p := fmt.Sprintf(<span class="string">"%s &#123;"</span>, t.Name())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> v.Field(i).CanInterface() &#123;</span><br><span class="line">			<span class="keyword">if</span> v.Field(i).Kind() == reflect.Slice &#123;</span><br><span class="line">				p += fmt.Sprintf(<span class="string">"\n\t %s(%s): %s"</span>, t.Field(i).Name, t.Field(i).Type, <span class="keyword">string</span>(v.Field(i).Bytes()))</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				p += fmt.Sprintf(<span class="string">"\n\t %s(%s): %v"</span>, t.Field(i).Name, t.Field(i).Type, v.Field(i).Interface())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p += <span class="string">"\n&#125;"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCounter</span><span class="params">(prefix <span class="keyword">string</span>)</span> *<span class="title">counter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> newCounter(prefix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCounter</span><span class="params">(prefix <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">counter</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">new</span>(counter)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		c.GroupId = args[<span class="number">0</span>].(<span class="keyword">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.IdKey = []<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">"%s:%s"</span>, prefix, c.GroupId))</span><br><span class="line"></span><br><span class="line">	turboNew(c)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">turboNew</span><span class="params">(c *counter)</span></span> &#123;</span><br><span class="line">	ct := custom.Load().(*Custom)</span><br><span class="line">	c.idChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int64</span>, ct.IdStep)</span><br><span class="line">	c.sig = <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	c.ReadOptions = gorocksdb.NewDefaultReadOptions()</span><br><span class="line">	signal.Notify(c.sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">	c.sender()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">sender</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ct := custom.Load().(*Custom)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-c.sig:</span><br><span class="line">				<span class="built_in">close</span>(c.idChan)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(c.idChan) &lt; ct.IdStep/<span class="number">10</span> &#123;</span><br><span class="line">					rdb := rocksdb.Load().(*Rocksdb)</span><br><span class="line">					<span class="keyword">if</span> c.ReadOptions == <span class="literal">nil</span> &#123;</span><br><span class="line">						c.ReadOptions = gorocksdb.NewDefaultReadOptions()</span><br><span class="line">					&#125;</span><br><span class="line">					slice, err := rdb.Get(c.ReadOptions, c.getIdKey())</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						fatal(UnexpectErrorCategory&#123;<span class="string">"counter sender error"</span>&#125;, err)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">var</span> idStr <span class="keyword">string</span></span><br><span class="line">						<span class="keyword">if</span> slice.Exists() &amp;&amp; slice.Size() &gt; <span class="number">0</span> &#123;</span><br><span class="line">							idStr = <span class="keyword">string</span>(slice.Data())</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							idStr = <span class="string">"0"</span></span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						cid, err := strconv.ParseInt(idStr, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">						<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">							fatal(UnexpectErrorCategory&#123;<span class="string">"counter sender error"</span>&#125;, err)</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							ct := custom.Load().(*Custom)</span><br><span class="line">							<span class="comment">// id回滚</span></span><br><span class="line">							<span class="keyword">if</span> ((<span class="number">1</span>&lt;&lt;<span class="number">63</span><span class="number">-1</span>)/<span class="number">2</span>)-ct.IdStep &lt; ct.IdStep &#123;</span><br><span class="line">								cid = <span class="number">0</span></span><br><span class="line">							&#125;</span><br><span class="line">							nextId := cid + <span class="keyword">int64</span>(ct.IdStep)</span><br><span class="line">							err = c.ackId(nextId)</span><br><span class="line">							<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">								fatal(UnexpectErrorCategory&#123;<span class="string">"counter sender error"</span>&#125;, err)</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">for</span> cid &lt; nextId &#123;</span><br><span class="line">								cid++</span><br><span class="line">								c.idChan &lt;- cid</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rocksdb to get a globally unique self increment ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">getId</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	id := &lt;-c.idChan</span><br><span class="line">	<span class="keyword">return</span> id, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//return -1, GetIdError&#123;bytes2string(c.IdKey)&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">GetId</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.getId()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">ackId</span><span class="params">(id <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	rdb := rocksdb.Load().(*Rocksdb)</span><br><span class="line">	err := rdb.Put(c.getIdKey(), []<span class="keyword">byte</span>(strconv.FormatInt(id, <span class="number">10</span>)))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">AckId</span><span class="params">(id <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.ackId(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Gets the key of the ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">getIdKey</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.IdKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们优先考虑可以通过内存直接通过<code>++</code>或者<code>+1操作符</code>分配的方式。我们重点看到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nextId := cid + <span class="keyword">int64</span>(ct.IdStep)</span><br><span class="line">err = c.ackId(nextId)</span><br><span class="line"><span class="keyword">for</span> cid &lt; nextId &#123;</span><br><span class="line">	cid++</span><br><span class="line">	c.idChan &lt;- cid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以再这里看到，我们通过拿到当前cid的数值，通过<code>idStep</code>来增加固定的步长，然后先通过回写nextId的值到rocksdb进行持久化，再通过<code>for</code>循环来对cid进行叠加，每次都推送到<code>有缓冲区</code>的<code>idChan</code>中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rocksdb to get a globally unique self increment ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">getId</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	id := &lt;-c.idChan</span><br><span class="line">	<span class="keyword">return</span> id, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">GetId</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.getId()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>func (c *counter) getId() (int64, error)</code> 来消费<code>idChan</code>中的id，达到一个获取id的效果。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id回滚</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="number">1</span>&lt;&lt;<span class="number">63</span><span class="number">-1</span>)/<span class="number">2</span>)-ct.IdStep &lt; ct.IdStep &#123;</span><br><span class="line">	cid = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到这里有一行代码，当int64的cid已经到达分配的极限了，那么cid就会进行回滚，基本保证了发号的可重复利用性。</p>
<p>扩展问题：id回溯了，怎么做递增判断？</p>
<p>这个问题其实有点类似tcp的syn回溯的问题。因为syn一开始是随机生成的，并且这个过程了syn是会不断增加的。当syn到达分配的极限进行了回溯的时候，如何比较大小？</p>
<p>我们查看到内核的tcp源码，可以看到提供的判断方式十分巧妙，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* The next routines deal with comparing 32 bit unsigned ints</span></span><br><span class="line"><span class="comment">* and worry about wraparound (automatic with unsigned arithmetic).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">before</span><span class="params">(__u32 seq1, __u32 seq2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (__s32)(seq1-seq2) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> after(seq2, seq1) before(seq1, seq2)</span></span><br></pre></td></tr></table></figure>

<p>为什么<code>（__s32）(seq1-seq2)&lt;0</code>就可以判断<code>seq1&lt;seq2</code>呢？这里的<code>__s32</code>是有符号整型的意思，而<code>__u32</code>则是无符号整型。<br>为了方便说明，我们以<code>unsigned char</code>和<code>char</code>为例来说明：</p>
<p>假设seq1=255， seq2=1（发生了回绕）<br>seq1 = 1111 1111 seq2 = 0000 0001<br>我们希望比较结果是 <code>seq1&lt;seq2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> seq1 - seq2&#x3D;</span><br><span class="line"> 1111 1111</span><br><span class="line">-0000 0001</span><br><span class="line">-----------</span><br><span class="line"> 1111 1110</span><br></pre></td></tr></table></figure>

<p>由于我们将结果转化成了有符号数，<code>由于最高位是1</code>，因此结果是<code>一个负数</code>，负数的绝对值为<br> 0000 0001 + 1 = 0000 0010 = 2 (补码：取反+1)</p>
<p>因此 <code>seq1 - seq2 &lt; 0</code></p>
<p>注意：</p>
<p>如果seq2=128的话，我们会发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> seq1 - seq2&#x3D;</span><br><span class="line"> 1111 1111</span><br><span class="line">-1000 0000</span><br><span class="line">-----------</span><br><span class="line"> 0111 1111</span><br></pre></td></tr></table></figure>

<p>此时结果尤为正了，判断的结果是<code>seq1&gt;seq2</code>。因此，上述算法正确的前提是，<code>回绕后的增量小于2^(n-1)-1</code>。</p>
<p>由于tcp序列号用的<code>32位无符号数</code>，因此可以支持的<code>回绕幅度是2^31-1</code>，满足要求了。</p>
<blockquote>
<p>但是由于我们这里不需要比较发号的先后次序，只需要保证其唯一性，所以这个回溯的大小比较问题，并不需要过多的关注</p>
</blockquote>
<h2 id="行级锁的实现"><a href="#行级锁的实现" class="headerlink" title="行级锁的实现"></a>行级锁的实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// dbID:tblID</span></span><br><span class="line">	<span class="comment">// dbID:tblID:rowID</span></span><br><span class="line">	rowLockLock sync.RWMutex</span><br><span class="line">	rowLock     rl</span><br><span class="line">	ttlTime     = <span class="keyword">int64</span>(<span class="number">30</span> * <span class="number">60</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	rl <span class="keyword">map</span>[<span class="keyword">string</span>]*lock</span><br><span class="line"></span><br><span class="line">	lock <span class="keyword">struct</span> &#123;</span><br><span class="line">		ttl  <span class="keyword">int64</span></span><br><span class="line">		lock sync.RWMutex</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// clean row lock, release memory</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t := time.NewTicker(<span class="number">10</span> * time.Minute)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">				ct := time.Now().Unix()</span><br><span class="line">				rowLockLock.Lock()</span><br><span class="line">				<span class="keyword">for</span> key, lock := <span class="keyword">range</span> rowLock &#123;</span><br><span class="line">					<span class="keyword">if</span> ct &gt; lock.ttl &#123;</span><br><span class="line">						<span class="built_in">delete</span>(rowLock, key)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				rowLockLock.Unlock()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	rowLock = <span class="built_in">make</span>(rl, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rowLockKey</span><span class="params">(dbId, tblId, rowId <span class="keyword">int64</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d:%d:%d"</span>, dbId, tblId, rowId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rl)</span> <span class="title">Lock</span><span class="params">(lockKey <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	rowLockLock.Lock()</span><br><span class="line">	m, ok := (*r)[lockKey]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		m = <span class="built_in">new</span>(lock)</span><br><span class="line">		(*r)[lockKey] = m</span><br><span class="line">		m.ttl = time.Now().Unix() + ttlTime</span><br><span class="line">	&#125;</span><br><span class="line">	rowLockLock.Unlock()</span><br><span class="line"></span><br><span class="line">	m.lock.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rl)</span> <span class="title">UnLock</span><span class="params">(lockKey <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	rowLockLock.Lock()</span><br><span class="line">	m, ok := (*r)[lockKey]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		m = <span class="built_in">new</span>(lock)</span><br><span class="line">		(*r)[lockKey] = m</span><br><span class="line">		m.ttl = time.Now().Unix() + ttlTime</span><br><span class="line">	&#125;</span><br><span class="line">	rowLockLock.Unlock()</span><br><span class="line"></span><br><span class="line">	m.lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rl)</span> <span class="title">RLock</span><span class="params">(lockKey <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	rowLockLock.Lock()</span><br><span class="line">	m, ok := (*r)[lockKey]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		m = <span class="built_in">new</span>(lock)</span><br><span class="line">		(*r)[lockKey] = m</span><br><span class="line">		m.ttl = time.Now().Unix() + ttlTime</span><br><span class="line">	&#125;</span><br><span class="line">	rowLockLock.Unlock()</span><br><span class="line"></span><br><span class="line">	m.lock.RLock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rl)</span> <span class="title">RUnlock</span><span class="params">(lockKey <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	rowLockLock.Lock()</span><br><span class="line">	m, ok := (*r)[lockKey]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		m = <span class="built_in">new</span>(lock)</span><br><span class="line">		(*r)[lockKey] = m</span><br><span class="line">		m.ttl = time.Now().Unix() + ttlTime</span><br><span class="line">	&#125;</span><br><span class="line">	rowLockLock.Unlock()</span><br><span class="line"></span><br><span class="line">	m.lock.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是行级锁的实现方式，主要是利用<code>sync.RWMutex</code>来实现读写锁，并且带有ttl的机制，每次加锁的时候，都会更新ttl的时间。<br>其中在<code>init阶段</code>，我们利用的ticker来实现对锁进行一个类似<code>LRU</code>的机制，对于不活跃的锁对象进行释放，防止在这里造成内存只增不减。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">updateHandle</span><span class="params">(result *Result, stmt *ast.UpdateStmt)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通过ast获取old数据</span></span><br><span class="line">	....</span><br><span class="line">	<span class="comment">// 行级锁锁定 </span></span><br><span class="line">	rowID, _ := item[<span class="number">0</span>].(json2.Number).Int64()</span><br><span class="line">	rowlockKey := rowLockKey(db.Id, tbl.Id, rowID)</span><br><span class="line">	rowLock.Lock(rowlockKey)</span><br><span class="line">	<span class="keyword">defer</span> rowLock.UnLock(rowlockKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新索引数据</span></span><br><span class="line">	<span class="keyword">for</span> _, index := <span class="keyword">range</span> indexs &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新为new数据</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逆波兰表达式-amp-amp-波兰表达式"><a href="#逆波兰表达式-amp-amp-波兰表达式" class="headerlink" title="逆波兰表达式 &amp;&amp; 波兰表达式"></a>逆波兰表达式 &amp;&amp; 波兰表达式</h2><p>这一块其实暂时还没实现，但是他的原理有必要和大家说一下，我们的db实现，都是基于<code>sql</code> 来实现的，我们知道 <code>sql</code> 中也有表达式计算，并且是有优先级之分的。</p>
<p><code>前/中/后</code>序遍历，相信大家基本都听说过，但是实际运用中少之又少，这是因为大家可能在实际中没有找到合适的模式和套用这些树的遍历方式。</p>
<ul>
<li><p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>
</li>
<li><p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p>
</li>
<li><p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">count</span> * price) <span class="keyword">AS</span> <span class="keyword">sum</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_id &lt; <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>order_id &lt; 10</code> 就是一个表达式，它有一个列输入参数： <code>order_id</code>，输出：<code>Bool</code></p>
<h3 id="RPN-表达式-逆波兰表示法"><a href="#RPN-表达式-逆波兰表示法" class="headerlink" title="RPN 表达式(逆波兰表示法)"></a>RPN 表达式(逆波兰表示法)</h3><p>RPN 是树的<code>后序遍历</code>，后序遍历在每个节点知道自己有几个子节点的时候等价于原本的树结构。</p>
<blockquote>
<p>所以你波澜是后序遍历：<code>左右中</code></p>
</blockquote>
<p>比如说我们有一个数学算式 <code>2 *（3 + 4）+ 5</code>：</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/RPN.png" alt=" RPN "></p>
<p>由于数学上习惯写法是<code>中序遍历</code>，我们通常要加上括号消除歧义（比如加减和乘除的顺序）。通过把操作符后移 我们得到 <code>RPN：2 3 4 + * 5 +</code>，这样我们无需括号就能无歧义地遍历这个表达式：</p>
<p><code>中序表达式</code>转<code>后序表达式</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原式：a+b*(c+d&#x2F;e)</span><br><span class="line">补全括号：(a+(b*(c+(d&#x2F;e))))</span><br><span class="line">操作符右移：(a(b(c(de)&#x2F;)+)*)+</span><br><span class="line">去掉括号：abcde&#x2F;+*+</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以波兰表达式是中序遍历：<code>左右中</code></p>
</blockquote>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/RPN2.png" alt=" RPN "></p>
<p>执行 RPN 的过程需要一个<code>栈</code>来缓存中间结果，比如说对于 <code>2 3 4 + * 5 +</code>，我们<code>从左到右</code>遍历表达式，遇到值就压入栈中。直到 <code>+</code> 操作符，栈中已经压入了 <code>2 3 4</code>。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/RPN3.png" alt=" RPN "></p>
<p>因为 <code>+</code> 是二元操作符，需要从栈中弹出两个值 <code>3 4</code>，结果为 <code>7</code>，<code>重新</code>压入栈中：</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/RPN4.png" alt=" RPN "></p>
<p>此时栈中的值为 <code>2 7</code>。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/RPN5.png" alt=" RPN "></p>
<p>下一个是 <code>*</code> 运算符，也需要弹出两个值 <code>2 7</code>，结果为 <code>14</code> 压入栈中。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/RPN6.png" alt=" RPN "></p>
<p>接着压入 <code>5</code> 。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/RPN7.png" alt=" RPN "></p>
<p>最后 <code>+</code> 运算符弹出 <code>14 5</code>，结果为 <code>19</code> ，压入<code>栈</code>。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/RPN8.png" alt=" RPN "></p>
<p>最后留在栈里的就是表达式的结果，因此，如果需要计算表达式优先级的话，可以采用RPN的方式来读取tree结构来进行顺序计算。</p>
<h2 id="单独使用DB例子："><a href="#单独使用DB例子：" class="headerlink" title="单独使用DB例子："></a>单独使用DB例子：</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/db-debug.png" alt=" db-debug "></p>
<p>这里有一个类似于<code>mysql-client</code> 的一个 <code>bin</code> 程序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"github.com/pingcap/parser"</span></span><br><span class="line">	<span class="string">"github.com/pingcap/parser/ast"</span></span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/logbdev"</span></span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/msource/v2"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sql = flag.String(<span class="string">"sql"</span>, <span class="string">""</span>, <span class="string">"Input Your Sql"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> os.Getenv(<span class="string">"DEBUG"</span>) == <span class="string">"true"</span> &#123;</span><br><span class="line">		logbdev.SetLevel(logbdev.DebugLevel)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	msource.PreparePhase()</span><br><span class="line">	store := msource.NewStore()</span><br><span class="line"></span><br><span class="line">	p := parser.New()</span><br><span class="line">	stmtNode, err := p.ParseOneStmt(*sql, <span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logbdev.Error(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, ok := stmtNode.(*ast.SelectStmt)</span><br><span class="line">	<span class="keyword">var</span> r *msource.Result</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		r, err = store.Query(*sql)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logbdev.Error(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		r, err = store.Execute(*sql)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logbdev.Error(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> r != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.Data != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> ar := r.Data.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *msource.InsertResultData:</span><br><span class="line">				logbdev.Info(ar.GetSliceInt64())</span><br><span class="line">				logbdev.Info(ar.Raw())</span><br><span class="line">			<span class="keyword">case</span> *msource.ShowDatabasesResultData:</span><br><span class="line">				logbdev.Info(ar.GetSliceString())</span><br><span class="line">			<span class="keyword">case</span> *msource.ShowTablesResultData:</span><br><span class="line">				logbdev.Info(ar.GetSliceString())</span><br><span class="line">			<span class="keyword">case</span> *msource.SelectResultSetData:</span><br><span class="line">				logbdev.Info(ar.GetFields())</span><br><span class="line">				logbdev.Info(ar.GetValues())</span><br><span class="line">				logbdev.Info(ar.Count())</span><br><span class="line">			<span class="keyword">case</span> *msource.DeleteResultData:</span><br><span class="line">				logbdev.Info(ar.GetAffected())</span><br><span class="line">			<span class="keyword">case</span> *msource.UpdateResultData:</span><br><span class="line">				logbdev.Info(ar.GetAffected())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		logbdev.Info(r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go run example&#x2F;msource_db&#x2F;customStmt&#x2F;main.go --sql &quot;INSERT INTO users(\&#96;name\&#96;,\&#96;age\&#96;,\&#96;last_login\&#96;) VALUES (\&quot;caiwenhui\&quot;, 18, 1614776101)&quot;</span><br><span class="line">go run example&#x2F;msource_db&#x2F;customStmt&#x2F;main.go --sql &quot;show databases;&quot;</span><br><span class="line">go run example&#x2F;msource_db&#x2F;customStmt&#x2F;main.go --sql &quot;show tables;&quot;</span><br><span class="line">go run example&#x2F;msource_db&#x2F;customStmt&#x2F;main.go --sql &quot;INSERT INTO mingchao.users2(\&#96;name\&#96;,\&#96;age\&#96;) VALUES (\&quot;caiwenhui\&quot;, 18),(\&quot;caiwenhui\&quot;, 19)&quot;</span><br><span class="line">go run example&#x2F;msource_db&#x2F;customStmt&#x2F;main.go --sql &quot;INSERT INTO mingchao.users2 VALUES (1000,\&quot;caiwenhui\&quot;, 18)&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以用对外暴露一个<code>msource.NewStore()</code>来创建一个存储器对象，然后通过API进行<code>数据库</code>的操作。</p>
<blockquote>
<p>NewStore我们用了sync.Pool封装，对象可以做到尽可能的复用。</p>
</blockquote>
<p>可以看到如果是<code>SELECT STMT</code>的话，我们调用的是<code>QUERY</code>API，如果是<code>非SELECT STMT</code>的话，我们调用的是<code>EXECUTE</code>API。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>基于目前尚未实现，所以暂时不再展开讲叙，后续可以升级处理的点为：</p>
<ul>
<li>事务处理，例如前面所说的<code>redolog</code>和<code>undolog</code>可实现。</li>
<li>orderby， 数据排序。</li>
<li>全双工的通信获取数据，无需一次性读取所有数据。</li>
<li>Explain执行计划的实现，逻辑根据执行计划走。</li>
</ul>
<h1 id="SPOUT"><a href="#SPOUT" class="headerlink" title="SPOUT"></a>SPOUT</h1><p>另外一篇文章中，记录了我们的<code>spout</code>的作用，在这里，再简单说一下，<code>spout</code> 是我们<code>msource</code>组件的核心角色，它是用于把数据推送到上层业务的所使用。上层业务通过<code>spout</code>角色提供的<code>API</code>，可以获取到从数据源拿到的数据。</p>
<p><code>spout</code> 自身保持了一套 <code>高可靠</code>, <code>高性能</code>, <code>可容错</code> 的数据机制，主要用于区别出<code>ACK</code>, <code>NACK</code>，并且自带有 <code>失败重传</code>, <code>多阶段状态机的checkpoint</code>等机制。</p>
<h2 id="channel-mode-大体数据流程图"><a href="#channel-mode-大体数据流程图" class="headerlink" title="channel-mode 大体数据流程图"></a>channel-mode 大体数据流程图</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/channel-mode.png" alt=" channel-mode "></p>
<p>之前有一篇文章，专门讲解channel-mode下，是如何工作的，这里不做过多详细的说明。简单复述一下。</p>
<p>channel模式下，是直接把数据推送到我们的<code>golang</code>的<code>channel</code> 当中，上层业务直接用过channel拿到数据，拿到数据后根据自身业务处理数据来判断可以ack或者nack掉数据，同时保存offset。</p>
<p>这里的问题就在于：</p>
<blockquote>
<p>由于我们是本地存储的offset，因为<code>不信任</code> kafka-client的<code>auto-commit</code>机制，当程序在某个节点crash的时候，这会让我们的程序在下次启动的时候，重复消费到数据或者遗漏数据</p>
</blockquote>
<p>缺点：每个partition的offset都需要顺序消费，在上层业务无法并发处理，这极大程度的降低了我们的消费效率</p>
<p>期望：如果我们提前把offset存储起来了，而不需要<code>ACK</code>之后再存储offset的话，那么我们就可以再上层业务并发的处理消息，而无需关注offset的问题</p>
<h2 id="db-demo-大体数据流程图"><a href="#db-demo-大体数据流程图" class="headerlink" title="db-demo 大体数据流程图"></a>db-demo 大体数据流程图</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/db-mode.png" alt=" db-mode "></p>
<p>鉴于<code>channel-mode</code>下的缺点，由此诞生了我们的<code>db-mode</code>，其原理是把数据先存储在本地的数据库，也就是我们上面所说的<code>db</code>，所以这里我们可以得出关系<code>spout &lt;- db</code>， <code>db角色</code> 可以被 <code>spout角色</code>所依赖。</p>
<p>我们创建了4个表来存储不同的数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	DefaultDatabase = <span class="string">"default"</span></span><br><span class="line">	DefaultDatabaseSql = <span class="string">"CREATE DATABASE IF NOT EXISTS `"</span> +</span><br><span class="line">		DefaultDatabase +</span><br><span class="line">		<span class="string">"`"</span></span><br><span class="line">	UseDefaultDatabase = <span class="string">"USE `"</span> +</span><br><span class="line">		DefaultDatabase +</span><br><span class="line">		<span class="string">"`"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 推送消息的时候使用</span></span><br><span class="line">	<span class="comment">// 因为正常消息过来的时候是没有row_id的，所以这个payload_marshal内的row_id没意义</span></span><br><span class="line">	<span class="comment">// 该表仅仅遍历数据到Runner表，到了Runner表和Loser表，Row_id才有用</span></span><br><span class="line">	SpoutStoreStorageTable         = <span class="string">"storage"</span></span><br><span class="line">	SpoutStoreStorageBuildTableSql = <span class="string">"create table if not exists "</span> + SpoutStoreStorageTable +</span><br><span class="line">		<span class="string">"("</span> +</span><br><span class="line">		<span class="string">"	`payload_marshal` varchar(255) not null comment \"序列化后的payload\","</span> +</span><br><span class="line">		<span class="string">"	`is_multi_phase` int(11) not null default 0 comment \"是否多阶段，0=否, 1=是\","</span> +</span><br><span class="line">		<span class="string">"	`cur_state` int(11) not null default 0 comment \"当前状态\","</span> +</span><br><span class="line">		<span class="string">"	`fin_state` int(11) not null default 0 comment \"最终状态\""</span> +</span><br><span class="line">		<span class="string">")"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Storage -&gt; Runner 使用</span></span><br><span class="line">	<span class="comment">// 刚启动服务的时候Runner-&gt;Storage有用</span></span><br><span class="line">	<span class="comment">// Ack的时候有用</span></span><br><span class="line">	SpoutStoreRunningTable         = <span class="string">"runner"</span></span><br><span class="line">	SpoutStoreRunningBuildTableSql = <span class="string">"create table if not exists "</span> + SpoutStoreRunningTable +</span><br><span class="line">		<span class="string">"("</span> +</span><br><span class="line">		<span class="string">"	`payload_marshal` varchar(255) not null comment \"序列化后的payload\","</span> +</span><br><span class="line">		<span class="string">"	`is_multi_phase` int(11) not null default 0 comment \"是否多阶段，0=否, 1=是\","</span> +</span><br><span class="line">		<span class="string">"	`cur_state` int(11) not null default 0 comment \"当前状态\","</span> +</span><br><span class="line">		<span class="string">"	`fin_state` int(11) not null default 0 comment \"最终状态\""</span> +</span><br><span class="line">		<span class="string">")"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Runner -&gt; Loser 使用</span></span><br><span class="line">	<span class="comment">// Nack的时候有用</span></span><br><span class="line">	<span class="comment">// 失败重传的时候用/刚启动服务的时候Loser-&gt;Storage有用</span></span><br><span class="line">	SpoutStoreLoserTable         = <span class="string">"loser"</span></span><br><span class="line">	SpoutStoreLoserBuildTableSql = <span class="string">"create table if not exists "</span> + SpoutStoreLoserTable +</span><br><span class="line">		<span class="string">"("</span> +</span><br><span class="line">		<span class="string">"	`payload_marshal` varchar(255) not null comment \"序列化后的payload\","</span> +</span><br><span class="line">		<span class="string">"	`is_multi_phase` int(11) not null default 0 comment \"是否多阶段，0=否, 1=是\","</span> +</span><br><span class="line">		<span class="string">"	`cur_state` int(11) not null default 0 comment \"当前状态\","</span> +</span><br><span class="line">		<span class="string">"	`fin_state` int(11) not null default 0 comment \"最终状态\""</span> +</span><br><span class="line">		<span class="string">")"</span></span><br><span class="line"></span><br><span class="line">	SpoutStoreDefaultOffsetTable         = <span class="string">"offset"</span></span><br><span class="line">	SpoutStoreDefaultOffsetBuildTableSql = <span class="string">"create table if not exists "</span> + SpoutStoreDefaultOffsetTable +</span><br><span class="line">		<span class="string">"("</span> +</span><br><span class="line">		<span class="string">"	`group_id` varchar(255) not null comment \"消费组\","</span> +</span><br><span class="line">		<span class="string">"	`topic` varchar(255) not null comment \"消费的topic\","</span> +</span><br><span class="line">		<span class="string">"	`partition` int(11) not null comment \"topic的partition\","</span> +</span><br><span class="line">		<span class="string">"	`offset` int(11) not null comment \"当前消费的offset\","</span> +</span><br><span class="line">		<span class="string">"    UNIQUE KEY `uniq_idx` (`group_id`,`topic`,`partition`)"</span> +</span><br><span class="line">		<span class="string">")"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/phase-deal-with.png" alt=" phase-deal-with "></p>
<h2 id="DB模式下的用法例子："><a href="#DB模式下的用法例子：" class="headerlink" title="DB模式下的用法例子："></a>DB模式下的用法例子：</h2><blockquote>
<p>channel-mode下的例子和db模式的差不多，但是更加简单，这里就不列出来了。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> common</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/logbdev"</span></span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/msource/v2"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/signal"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreparePhase</span><span class="params">()</span></span> &#123;</span><br><span class="line">	logbdev.SetLevel(logbdev.DebugLevel)</span><br><span class="line">	S = msource.PreparePhase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> S *msource.Spout</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CoreStart</span><span class="params">(function <span class="keyword">func</span>(payload *msource.Payload)</span>)</span> &#123;</span><br><span class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建主协程上下文</span></span><br><span class="line">	ctx, cannel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动msource，并且传递主协程上下文，用于任务间的通信控制</span></span><br><span class="line">	S.Start(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册信号量</span></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-sig:</span><br><span class="line">				cannel()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里我们可以再创建更多的worker协助我们的消费数据</span></span><br><span class="line">	<span class="comment">// 使用方式基本向后兼容</span></span><br><span class="line">	innerWorker := <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	logbdev.Infof(<span class="string">"total chan: %d\n"</span>, S.ChanSize())</span><br><span class="line">	<span class="comment">// 主协程中创建子协程（worker）工作</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; S.ChanSize(); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> ii := <span class="number">0</span>; ii &lt; innerWorker; ii++ &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx, idx2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">				<span class="keyword">defer</span> wg.Done()</span><br><span class="line">				logbdev.Infof(<span class="string">"start chan[%d-%d]\n"</span>, idx, idx2)</span><br><span class="line">				payloadCh := S.GetPayloadChanById(idx)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> payload := <span class="keyword">range</span> payloadCh.GetCh() &#123;</span><br><span class="line">					function(payload)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(i, ii)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待子协程结束</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">// 等待msource退出</span></span><br><span class="line">	S.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a>ACK</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/logbdev"</span></span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/msource/v2"</span></span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/msource/v2/example/spout/db/common"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	common.CoreStart(<span class="function"><span class="keyword">func</span><span class="params">(payload *msource.Payload)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := common.S.Ack(payload); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logbdev.Error(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NACK"><a href="#NACK" class="headerlink" title="NACK"></a>NACK</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/logbdev"</span></span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/msource/v2"</span></span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/msource/v2/example/spout/db/common"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	common.PreparePhase()</span><br><span class="line">	common.CoreStart(<span class="function"><span class="keyword">func</span><span class="params">(payload *msource.Payload)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := common.S.MarkFailure(payload); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logbdev.Error(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="STATE-MACHINE"><a href="#STATE-MACHINE" class="headerlink" title="STATE-MACHINE"></a>STATE-MACHINE</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/logbdev"</span></span><br><span class="line">	<span class="string">"gitlab.mingchao.com/basedev-deps/msource/v2/example/spout/db/common"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/signal"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStateMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">	phases []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(msm *MyStateMachine)</span> <span class="title">AddPhase</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	msm.phases = <span class="built_in">append</span>(msm.phases, name)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get all phase</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(msm *MyStateMachine)</span> <span class="title">GetPhases</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> msm.phases</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	common.PreparePhase()</span><br><span class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建主协程上下文</span></span><br><span class="line">	ctx, cannel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动msource，并且传递主协程上下文，用于任务间的通信控制</span></span><br><span class="line">	<span class="comment">// 需要设置为多阶段的话，必须设置状态机，并且在msource服务Start之前设置</span></span><br><span class="line">	sms := &amp;MyStateMachine&#123;&#125;</span><br><span class="line">	_ = sms.AddPhase(<span class="string">"step1"</span>)</span><br><span class="line">	_ = sms.AddPhase(<span class="string">"step2"</span>)</span><br><span class="line">	_ = sms.AddPhase(<span class="string">"step3"</span>)</span><br><span class="line">	common.S.SetStateMachine(sms)</span><br><span class="line">	common.S.Start(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册信号量</span></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-sig:</span><br><span class="line">				cannel()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	logbdev.Infof(<span class="string">"total chan: %d\n"</span>, common.S.ChanSize())</span><br><span class="line">	<span class="comment">// 主协程中创建子协程（worker）工作</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; common.S.ChanSize(); i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		chCtx, _ := context.WithCancel(ctx)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>, childCtx context.Context)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			logbdev.Infof(<span class="string">"start chan[%d]\n"</span>, idx)</span><br><span class="line">			payloadCh := common.S.GetPayloadChanById(idx)</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> payload := &lt;-payloadCh.GetCh():</span><br><span class="line">					<span class="comment">// 不同阶段之间如果相互无依赖的话，则可以并发处理</span></span><br><span class="line">					<span class="comment">// 否则请使用同步的方式</span></span><br><span class="line">					<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">					wg.Add(<span class="number">1</span>)</span><br><span class="line">					<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">						<span class="keyword">defer</span> wg.Done()</span><br><span class="line">						phase := <span class="string">"step1"</span></span><br><span class="line">						<span class="keyword">if</span> common.S.CanTransition(payload, phase) &#123;</span><br><span class="line">							fmt.Println(<span class="string">"Do Step 1 something"</span>)</span><br><span class="line">							_ = common.S.Transition(payload, phase)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;()</span><br><span class="line"></span><br><span class="line">					wg.Add(<span class="number">1</span>)</span><br><span class="line">					<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">						<span class="keyword">defer</span> wg.Done()</span><br><span class="line">						phase := <span class="string">"step2"</span></span><br><span class="line">						<span class="keyword">if</span> common.S.CanTransition(payload, phase) &#123;</span><br><span class="line">							fmt.Println(<span class="string">"Do Step 2 something"</span>)</span><br><span class="line">							_ = common.S.Transition(payload, phase)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;()</span><br><span class="line"></span><br><span class="line">					wg.Add(<span class="number">1</span>)</span><br><span class="line">					<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">						<span class="keyword">defer</span> wg.Done()</span><br><span class="line">						phase := <span class="string">"step3"</span></span><br><span class="line">						<span class="keyword">if</span> common.S.CanTransition(payload, phase) &#123;</span><br><span class="line">							fmt.Println(<span class="string">"Do Step 3 something"</span>)</span><br><span class="line">							_ = common.S.Transition(payload, phase)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;()</span><br><span class="line">					wg.Wait()</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 多阶段的请看下，Ack非必须要，如果手动调用ack的话，那么等于一条条同步删除</span></span><br><span class="line">					<span class="comment">// msource 在后台会定期检测runner中的状态机数据</span></span><br><span class="line">					<span class="comment">//if err := common.S.Ack(payload); err != nil &#123;</span></span><br><span class="line">					<span class="comment">//	logbdev.Error(err)</span></span><br><span class="line">					<span class="comment">//&#125;</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">					fmt.Println(<span class="string">"Done"</span>)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i, chCtx)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待子协程结束</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">// 等待msource退出</span></span><br><span class="line">	common.S.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小知识总结"><a href="#小知识总结" class="headerlink" title="小知识总结"></a>小知识总结</h1><h2 id="time组件"><a href="#time组件" class="headerlink" title="time组件"></a>time组件</h2><p>在开发的过程中，<code>time组件</code>用得还是比较多的，因为有各种异步任务在后台运行，常规的用法就不记录讲述了，这里说一下一些注意的点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; After waits for the duration to elapse and then sends the current time</span><br><span class="line">&#x2F;&#x2F; on the returned channel.</span><br><span class="line">&#x2F;&#x2F; It is equivalent to NewTimer(d).C.</span><br><span class="line">&#x2F;&#x2F; The underlying Timer is not recovered by the garbage collector</span><br><span class="line">&#x2F;&#x2F; until the timer fires. If efficiency is a concern, use NewTimer</span><br><span class="line">&#x2F;&#x2F; instead and call Timer.Stop if the timer is no longer needed.</span><br><span class="line">func After(d Duration) &lt;-chan Time &#123;</span><br><span class="line">	return NewTimer(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到这个<code>API</code>，如果想要用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span>*time.Second)):</span><br><span class="line">			fmt.Println(<span class="string">"时间到了"</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"go on"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个例子，如果我们这么用的话，每1秒都会重新创建一个Timer对象，不断在堆空间申请内存，然后gc-worker再大量回收没有再使用的对象内存。这就导致cpu做了额外的一些无效工作。</p>
<p>所以这种用法我是不推荐的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">Reset</span><span class="params">(d Duration)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.r.f == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"time: Reset called on uninitialized Timer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	w := when(d)</span><br><span class="line">	<span class="keyword">return</span> resetTimer(&amp;t.r, w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到其实<code>Timer</code> 其实有一个<code>Reset</code>的API，我们可以对同一个timer进行<code>Reset</code>的操作，不断是重置时间即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d := <span class="number">1</span>*time.Second</span><br><span class="line">t:= NewTimer(d)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">			t.Reset(d)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"go on"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h2><p>make函数是一个很强大的函数，我们会经常使用到，但是有一些细节，需要大家知道的。</p>
<p><code>make([]byte,0,10)</code> 与 <code>make([]byte,10)</code> 这是2中不同的切片，对于可能刚学习golang的小伙伴来说，会有点疑惑，但是这是需要了解的，如果是三个参数的时候，一个是<code>cap</code>,一个是<code>len</code>，他们是有区别的。如果是三个参数的话，那代表当前大小<code>cap</code> = <code>len</code></p>
<p>我们经常会用三个参数来进行预分配空间，第二个参数默认都是填写0来进行优化，特别是我们在写<code>DB</code>的时候，用到了大量<code>[]byte</code>类型，在组装编码字节的时候，我们就需要使用这种方式来处理，否则。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">a = <span class="built_in">append</span>(a, []<span class="keyword">byte</span>&#123;<span class="string">'a'</span>&#125;) <span class="comment">// a = [97]</span></span><br><span class="line"></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">a = <span class="built_in">append</span>(a, []<span class="keyword">byte</span>&#123;<span class="string">'a'</span>&#125;) <span class="comment">// a = [0,0,0,0,0,97]</span></span><br></pre></td></tr></table></figure>

<p>看到这里，大家就会明白区别。</p>
<h2 id="once函数"><a href="#once函数" class="headerlink" title="once函数"></a>once函数</h2><p>有些时候，我们想要保证只运行一次，这里，我们就需要借助 <code>sync.Once</code>，需要注意的是 一个<code>sync.Once</code>只能与一个函数绑定！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">once := <span class="built_in">new</span>(sync.Once)</span><br><span class="line">callback:= <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">"我只想运行一次"</span>)&#125;</span><br><span class="line">once.Do(callback) <span class="comment">// 会 输出</span></span><br><span class="line"></span><br><span class="line">once.Do(callback) <span class="comment">// 无 输出</span></span><br><span class="line">once.Do(callback) <span class="comment">// 无 输出</span></span><br><span class="line">once.Do(callback) <span class="comment">// 无 输出</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义marshal和unmarshal"><a href="#自定义marshal和unmarshal" class="headerlink" title="自定义marshal和unmarshal"></a>自定义marshal和unmarshal</h2><p>有时候，我们想要自己定义json的<code>marshal</code> 和 <code>unmarshal</code>，这里我们的<code>发号计数器</code> 就用到了，用它的原因其实是因为，我们的发号计数器在发号的过程中，其实是后台跑着一个异步任务在发号，所以在被反编码的时候，我们需要启动这个异步任务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	c.IdKey = data[<span class="number">1</span> : <span class="built_in">len</span>(data)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重点关注这里</span></span><br><span class="line">	turboNew(c)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(c.IdKey)+<span class="number">2</span>)</span><br><span class="line">	b = <span class="built_in">append</span>(b, <span class="string">'"'</span>)</span><br><span class="line">	b = <span class="built_in">append</span>(b, c.IdKey...)</span><br><span class="line">	b = <span class="built_in">append</span>(b, <span class="string">'"'</span>)</span><br><span class="line">	<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">turboNew</span><span class="params">(c *counter)</span></span> &#123;</span><br><span class="line">	ct := custom.Load().(*Custom)</span><br><span class="line">	c.idChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int64</span>, ct.IdStep)</span><br><span class="line">	c.sig = <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	c.ReadOptions = gorocksdb.NewDefaultReadOptions()</span><br><span class="line">	signal.Notify(c.sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里会启动一个异步任务</span></span><br><span class="line">	c.sender()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *counter)</span> <span class="title">sender</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 异步任务</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lockfree-queue和lockfree-stack"><a href="#lockfree-queue和lockfree-stack" class="headerlink" title="lockfree-queue和lockfree-stack"></a>lockfree-queue和lockfree-stack</h2><p>我们知道如果想要做到并发安全的话，普遍做法就是2种</p>
<ul>
<li>无锁化结构的设计（需要针对特定的业务常用，并且不允许乱用）</li>
<li>有锁结构</li>
</ul>
<p>无锁化(<code>lock-free</code>)的实现方式有很多种，在开发的过程中，我也有想过利用<code>lock-free-stack</code>以及<code>lock-free-queue</code>，分别想要运用在<code>RPN</code>的实现以及<code>发号器</code>当中，虽然后来发现用不到，但是可以拿到这里和大家分享一下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inrInt64 Increase</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inrInt64</span><span class="params">(i *<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	t := <span class="keyword">int64</span>(+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		value := atomic.LoadInt64(i)</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt64(i, value, value+t) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(time.Nanosecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dcrInt64 Decrease</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dcrInt64</span><span class="params">(i *<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	t := <span class="keyword">int64</span>(<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		value := atomic.LoadInt64(i)</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt64(i, value, value+t) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(time.Nanosecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LKStack returns an empty queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLKStack</span><span class="params">()</span> *<span class="title">LKStack</span></span> &#123;</span><br><span class="line">	n := unsafe.Pointer(&amp;node&#123;&#125;)</span><br><span class="line">	<span class="keyword">return</span> &amp;LKStack&#123;head: n&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LKStack is a lock-free unbounded stack.</span></span><br><span class="line"><span class="keyword">type</span> LKStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">len</span>  <span class="keyword">int64</span></span><br><span class="line">	head unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *LKStack)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q.Len() == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *LKStack)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q.<span class="built_in">len</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LKStack puts the given value v at the tail of the stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *LKStack)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	n := &amp;node&#123;value: v&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		head := load(&amp;q.head)</span><br><span class="line">		next := load(&amp;n.next)</span><br><span class="line">		cas(&amp;n.next, next, head)</span><br><span class="line">		<span class="keyword">if</span> cas(&amp;q.head, head, n) &#123;</span><br><span class="line">			inrInt64(&amp;q.<span class="built_in">len</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		time.Sleep(time.Nanosecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop removes and returns the value at the head of the stack.</span></span><br><span class="line"><span class="comment">// It returns nil if the stack is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *LKStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		head := load(&amp;q.head)</span><br><span class="line">		next := load(&amp;head.next)</span><br><span class="line">		<span class="keyword">if</span> next == <span class="literal">nil</span> &#123; <span class="comment">// is stack empty?</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// read value before CAS otherwise another pop might free the next node</span></span><br><span class="line">			v := head.value</span><br><span class="line">			<span class="keyword">if</span> cas(&amp;q.head, head, next) &#123;</span><br><span class="line">				dcrInt64(&amp;q.<span class="built_in">len</span>)</span><br><span class="line">				<span class="keyword">return</span> v <span class="comment">// Pop is done.  return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(time.Nanosecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// load from atomic load pointer node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(p *unsafe.Pointer)</span> <span class="params">(n *node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (*node)(atomic.LoadPointer(p))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cas swap set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cas</span><span class="params">(p *unsafe.Pointer, old, <span class="built_in">new</span> *node)</span> <span class="params">(ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atomic.CompareAndSwapPointer(</span><br><span class="line">		p, unsafe.Pointer(old), unsafe.Pointer(<span class="built_in">new</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也不过多在这里描述了，我们大家查看源码吧，主要就是利用了<code>atomic</code>包中的<code>原子性</code>操作<code>CompareAndSwapXxx</code>, 因为这是一个原子性的指令，合理的运用即可做到<code>无锁化并发安全</code>的结构。</p>
<p><code>atomic</code>包的<code>CompareAndSwapXxx</code>其实就是一个<code>CAS</code>的理念，用<code>乐观锁(逻辑锁)</code>来做数据处理。</p>
<h2 id="unsafa包中的指针的作用：零拷贝string和byte的转换"><a href="#unsafa包中的指针的作用：零拷贝string和byte的转换" class="headerlink" title="unsafa包中的指针的作用：零拷贝string和byte的转换"></a>unsafa包中的指针的作用：零拷贝string和byte的转换</h2><p><code>零拷贝(zero-copy)</code>，传统较多的说法就是无需经过用户态到内核态到数据copy，即可做到想做的事情。 通俗一点就是不经过copy就能转换数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span></span><br><span class="line">    Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span></span><br><span class="line">    Len  <span class="keyword">int</span></span><br><span class="line">    Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是String和slice的底层数据结构，他们基本是一致的，区别其实就是在于一个有Cap，一个是固定的Len。</p>
<p>只需要共享底层 Data 和 Len 就可以实现 zero-copy。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2bytes</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2string</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="context控制上下文也讲解一下"><a href="#context控制上下文也讲解一下" class="headerlink" title="context控制上下文也讲解一下"></a>context控制上下文也讲解一下</h2><p>我们这里用到了大量协程，他们之间有一些或许是有上下文关系的，因此，我们这里就需要用到<code>context</code>来对协程进行一个上下文的管理，做到协助的作用。</p>
<p>特别是我们在退出程序的时候，我们想要某一些异步任务<code>优雅</code>,<code>可靠</code>,<code>安全</code>的退出程序，那么我们就需要用到context来控制每个后台运行的程序。</p>
<p>我们这里用到比较多的其实就是 <code>context.WithCancel(ctx)</code>， 我们需要管理每个协程的退出需要做的事情，例如：我需要msource在退出的时候，保存一下当前在内存中最新的数据到rocksdb中，那么这个时候context的作用就十分有效了。</p>
<h2 id="pprof的查看"><a href="#pprof的查看" class="headerlink" title="pprof的查看"></a>pprof的查看</h2><p>要利用pprof粗略查看性能，及时它不能准确的反馈出所有的问题，起码它能帮助我们在前面的大问题上更容易发现问题。</p>
<h2 id="sync-Pool如何做到优化"><a href="#sync-Pool如何做到优化" class="headerlink" title="sync.Pool如何做到优化"></a>sync.Pool如何做到优化</h2><ul>
<li>对STW暂停时间做了优化, 避免大的sync.Pool严重影响STW时间</li>
<li>第二个优化是GC时入对<code>sync.Pool</code>进行回收，不会一次将池化对象全部回收，这就避免了<code>sync.Pool</code>释放对象和重建对象导致的性能尖刺，造福于<code>sync.Pool</code>重度用户。</li>
<li>第三个就是对性能的优化。</li>
<li>对以上的改进主要是两次提交：<br><a href="https://github.com/golang/go/commit/d5fd2dd6a17a816b7dfd99d4df70a85f1bf0de31#diff-491b0013c82345bf6cfa937bd78b690d" target="_blank" rel="noopener">sync: use lock-free structure for Pool stealing</a><br><a href="https://github.com/golang/go/commit/2dcbf8b3691e72d1b04e9376488cef3b6f93b286#diff-491b0013c82345bf6cfa937bd78b690d" target="_blank" rel="noopener">sync: smooth out Pool behavior over GC with a victim cache</a></li>
</ul>
<p>分别是用到了<code>无锁化结构</code> 以及程序GC的行为的优化</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/数据结构/">数据结构</a>, <a href="/categories/数据结构/数据库/">数据库</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Kafka/">Kafka</a><a href="/tags/TiDB/">TiDB</a><a href="/tags/RocketDB/">RocketDB</a><a href="/tags/SQL/">SQL</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 白菜(whiteCcinn)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>