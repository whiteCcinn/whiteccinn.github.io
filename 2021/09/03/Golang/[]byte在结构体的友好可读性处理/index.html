<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>【Golang】- []byte在结构体的友好可读性处理 | 白菜君の技术库</title>

  
  <meta name="author" content="白菜(whiteCcinn)">
  

  
  <meta name="description" content="知道做不到，等于不知道">
  

  
  <meta name="keywords" content="白菜,文辉,技术博客,whiteCcinn">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="【Golang】- []byte在结构体的友好可读性处理"/>

  <meta property="og:site_name" content="白菜君の技术库"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="白菜君の技术库" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">白菜君の技术库</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/">文章</a></li>
      
        <li><a href="/tags/">标签</a></li>
      
        <li><a href="/categories/">分类</a></li>
      
        <li><a href="/about/">关于我</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>【Golang】- []byte在结构体的友好可读性处理</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/09/03/Golang/[]byte在结构体的友好可读性处理/" rel="bookmark">
        <time class="entry-date published" datetime="2021-09-03T03:16:51.000Z">
          2021-09-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有些时候，我们会发现，<code>[]byte</code> 类型在 <code>struct</code> 中，是必不可少的结构体，因为用了<code>[]byte</code>代表可以存储字节数据，也可以叫做二进制安全的存储。代表可以存储任何数据。</p>
<p>如何才能做到在序列化json的情况下，可以<code>Println</code>出一个可读性的在<code>struct</code>的<code>[]byte</code>呢？</p>
<a id="more"></a>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>最近我在开发我们的部门的配置服务，需要提供一个配置工具。里面设计的一个struct，有一个<code>[]byte</code>类型，就是用来存储实际数据的。但是我们在这里的时候，我们有一个查看原始数据的需求，因为我们的数据经过了<code>加密</code>，和<code>压缩</code>，最终才会放到该结构体。</p>
<p>简化结构体，这里列举一下例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> V []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">	PublishTime     <span class="keyword">int64</span></span><br><span class="line">	PublishDateTime <span class="keyword">string</span></span><br><span class="line">	Value           V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到，我们这里的<code>Value</code>实际就是一个<code>[]byte</code>，我们把这个结构体经过<code>json.Marshal</code>之后推送到远端<code>kv</code>服务中，一切都正常。</p>
<p>但是当我们需要查看的时候，就需要从远端的<code>kv</code>拉回来，经过<code>json.Unmarsha</code>处理，这个时候，我们会发现：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"PublishTime"</span>:<span class="number">1630636657</span>,<span class="attr">"PublishDateTime"</span>:<span class="string">"2021-09-03 02:37:37.8693941 +0000 UTC m=+0.015759101"</span>,<span class="attr">"Value"</span>:<span class="string">"MTIzCg=="</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们看到<code>Value</code>是一个经过<code>base64</code>加密过的数据，这是因为默认情况下<code>[]byte</code>将会把数据经过<code>base64</code>变成<code>字符串</code>来符合<code>json数据类型</code>。那么我们有什么版本让他显示出原来真是的数据呢？</p>
<p>这里我使用了一个方案，借助多一个数据结构，对<code>T V</code>进行一个<code>重组</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VO []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ValueReadable <span class="keyword">struct</span> &#123;</span><br><span class="line">	PublishTime     <span class="keyword">int64</span></span><br><span class="line">	PublishDateTime <span class="keyword">string</span></span><br><span class="line">	Value           VO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *VO)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *VO)</span> <span class="title">UnmarshalJSON</span><span class="params">(input []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	*b = input</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义多一个<code>大体上一致</code>的结构体，注意此时的<code>Value</code>不再是<code>V</code>，而是<code>VO</code>，我们对<code>VO</code>自定义json序列化的行为，那就是把<code>base64</code>的行为给去掉。</p>
<p>这样子，我们得到的数据就会是</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"PublishTime"</span>:<span class="number">1630636657</span>,<span class="attr">"PublishDateTime"</span>:<span class="string">"2021-09-03 02:37:37.8693941 +0000 UTC m=+0.015759101"</span>,<span class="attr">"Value"</span>:<span class="number">123</span>&#125;</span><br></pre></td></tr></table></figure>

<p>细心的朋友一定发现了问题所在，那就是<code>Value</code>和<code>ValueReadable</code>怎么进行转换。</p>
<p>因为你存的时候是通过<code>Value</code>进行<code>marshal</code>的，那么你的<code>unmarsha</code>行为一定要对应才能解到正确的数据。</p>
<p>所以这里，就是我们的一个重点，我们需要借助<code>unsafe.Pointer</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// because []byte in struct will be base64encode</span></span><br><span class="line"><span class="comment">// so you will see such as "Ik1USXpDZz09Ig=="</span></span><br><span class="line"><span class="comment">// we should base64decode, so we custom a struct do not base64encode</span></span><br><span class="line"><span class="comment">// struct type transform use unsafe.Pointer</span></span><br><span class="line">p := unsafe.Pointer(&amp;persistenceValue)</span><br><span class="line">vr := (*config_sync.ValueReadable)(p)</span><br><span class="line">tv, err := json.Marshal(vr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(tv))</span><br></pre></td></tr></table></figure>

<p>我们利用<code>unsafe</code>的<code>指针</code>数据类型，进行一个强制转换，为什么会成功呢，因为在内存对齐的结构上，这2个对象的内存是一致的，所以我们就可以进行强制转换，而不用担心有<code>panic</code>的产生。这只是<code>unsafe</code>指针的一个灵活运用。但是可以达到我们的目的，十分的有效果。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"PublishTime"</span>:<span class="number">1630636657</span>,<span class="attr">"PublishDateTime"</span>:<span class="string">"2021-09-03 02:37:37.8693941 +0000 UTC m=+0.015759101"</span>,<span class="attr">"Value"</span>:<span class="number">123</span>&#125;</span><br></pre></td></tr></table></figure>

<p>转换后，就可以看到我原本的数据了 <code>123</code>.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Golang/">Golang</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Golang/">Golang</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 白菜(whiteCcinn)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>